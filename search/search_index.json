{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bolig Ping","text":"<p>Get a ping when your dream home in Denmark becomes available on Boligsiden.dk.</p> <p> </p> <p>Developer:</p> <ul> <li>Dan Saattrup Nielsen (saattrupdan@gmail.com)</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>The easiest way to use the package is as a uv tool. You can simply start searching for properties using the following command:</p> <pre><code>uvx bolig-ping --city k\u00f8benhavn\n</code></pre> <p>This both installs the package and runs the command. All the available options are listed below, but you can always get these by running the following command:</p> <pre><code>uvx bolig-ping --help\n</code></pre> <p>To be able to send emails, you have to create a Google app password, and store both your Gmail email address and the app password in the environment variables <code>GMAIL_EMAIL</code> and <code>GMAIL_PASSWORD</code>, respectively. You can also simply store these in a <code>.env</code> file, as follows:</p> <pre><code>GMAIL_EMAIL=&lt;your-email&gt;@gmail.com\nGMAIL_PASSWORD=&lt;your-app-password&gt;\n</code></pre> <p>With this set up, you can now use the <code>--email</code> option to receive an email with new properties that match your search criteria:</p> <pre><code>uvx bolig-ping --city k\u00f8benhavn --email &lt;receiving-email&gt;\n</code></pre> <p>This will then send an email from your <code>GMAIL_EMAIL</code> to the <code>receiving-email</code> address. You can also set up a recurring search if you have a server available. In this case, you can add the following line to your crontab on a server, to run the search every hour:</p> <pre><code>0 * * * * &lt;uvx-full-path&gt; bolig-ping &lt;search-arguments&gt;\n</code></pre> <p>Here <code>&lt;uvx-full-path&gt;</code> is the full path to the <code>uvx</code> command, which you can find by running <code>which uvx</code> in your terminal.</p>"},{"location":"#all-options","title":"All options","text":"<p>The following options are available:</p> <ul> <li><code>--city/-c</code>: The city you want to search in. This argument can be used several times   to search in multiple cities, e.g., <code>-c aarhus -c odense</code>. If you do not specify any   city then you'll be searching for homes in all of Denmark!</li> <li><code>--min-price</code>: The minimum price of the property, in DKK. Default is no minimum price.</li> <li><code>--max-price</code>: The maximum price of the property, in DKK. Default is no maximum price.</li> <li><code>--min-monthly-fee</code>: The minimum monthly fee of the property, in DKK. Default is no   minimum monthly fee.</li> <li><code>--max-monthly-fee</code>: The maximum monthly fee of the property, in DKK. Default is no   maximum monthly fee.</li> <li><code>--min-rooms</code>: The minimum number of rooms in the property. Default is no minimum   number of rooms.</li> <li><code>--max-rooms</code>: The maximum number of rooms in the property. Default is no maximum   number of rooms.</li> <li><code>--min-size</code>: The minimum size of the property, in square meters. Default is no   minimum size.</li> <li><code>--max-size</code>: The maximum size of the property, in square meters. Default is no   maximum size.</li> <li><code>--query/-q</code>: The query to search for in the property description. This argument can   be used several times to search for multiple queries, e.g., <code>-q badekar -q altan</code>.</li> <li><code>--property-type/-t</code>: The type of property to search for. The available property   types are <code>ejerlejlighed</code>, <code>andelslejlighed</code> and <code>house</code>. This argument can be used   several times to search for multiple property types, e.g., <code>-t ejerlejlighed -t house</code>.   Default is searching for all property types.</li> <li><code>--email</code>: The email address you want to receive the ping on. Note that this needs to   have the <code>GMAIL_EMAIL</code> and <code>GMAIL_PASSWORD</code> environment variables set, as described   above. Default is to use no email address, and instead print the properties to the   console.</li> <li><code>--cache/--no-cache</code>: Whether to use the cache or not. Default is to use the cache,   but you can disable it by using the <code>--no-cache</code> flag. This is useful if you want to   see all the results, and not just the new ones. The cache is stored in the   <code>.boligping_cache</code> file in the current directory.</li> <li><code>--headless/--no-headless</code>: Whether to run the scraper in headless mode. Mostly used   for debugging.</li> </ul>"},{"location":"api/bolig_ping/","title":"bolig_ping","text":"bolig_ping<p> source package bolig_ping </p> <p>Get a ping when your dream home becomes available.</p> <p> Modules </p> <ul> <li> <p>bolig_ping.cache \u2014 Cache to store already sent homes.</p> </li> <li> <p>bolig_ping.cli \u2014 Command line interface for the project.</p> </li> <li> <p>bolig_ping.data_models \u2014 Data models used in the project.</p> </li> <li> <p>bolig_ping.email \u2014 Sending emails with home listings.</p> </li> <li> <p>bolig_ping.filtering \u2014 Filtering of scraped results.</p> </li> <li> <p>bolig_ping.scraper \u2014 Scraping homes available satisfying the given criteria.</p> </li> </ul>"},{"location":"src/bolig_ping/","title":"bolig_ping","text":"bolig_ping<p> docs package bolig_ping </p> <pre><code>\"\"\"Get a ping when your dream home becomes available.\"\"\"\n</code></pre>"},{"location":"api/bolig_ping/cache/","title":"bolig_ping.cache","text":"bolig_ping.cache<p> source module bolig_ping.cache </p> <p>Cache to store already sent homes.</p> <p> Functions </p> <ul> <li> <p>store_to_cache \u2014 Store the homes to the cache.</p> </li> <li> <p>remove_cached_homes \u2014 Remove the cached homes from the list of homes.</p> </li> </ul> <p> source store_to_cache(homes: list[Home], emails: list[str], cache_path: Path = Path('.bolig_ping_cache')) \u2192 None </p> <p>Store the homes to the cache.</p> <p> Parameters </p> <ul> <li> <p>homes :  list[Home] \u2014 The homes to store in the cache.</p> </li> <li> <p>emails :  list[str] \u2014 The receiver(s) of the homes.</p> </li> <li> <p>cache_path :  optional \u2014 The path to the cache file. Defaults to \".bolig_ping_cache\".</p> </li> </ul> <p> source remove_cached_homes(homes: list[Home], emails: list[str], cache_path: Path = Path('.bolig_ping_cache')) \u2192 list[Home] </p> <p>Remove the cached homes from the list of homes.</p> <p> Parameters </p> <ul> <li> <p>homes :  list[Home] \u2014 The homes to remove the cached homes from.</p> </li> <li> <p>emails :  list[str] \u2014 The receiver(s) of the homes.</p> </li> <li> <p>cache_path :  optional \u2014 The path to the cache file. Defaults to \".bolig_ping_cache\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[Home] \u2014 The homes without the cached homes.</p> </li> </ul>"},{"location":"src/bolig_ping/cache/","title":"bolig_ping.cache","text":"bolig_ping.cache<p> docs module bolig_ping.cache </p> <pre><code>\"\"\"Cache to store already sent homes.\"\"\"\n\nimport json\nfrom pathlib import Path\n\nfrom .data_models import Home\n\n\ndef store_to_cache(docs\n    homes: list[Home], emails: list[str], cache_path: Path = Path(\".bolig_ping_cache\")\n) -&gt; None:\n    \"\"\"Store the homes to the cache.\n\n    Args:\n        homes:\n            The homes to store in the cache.\n        emails:\n            The receiver(s) of the homes.\n        cache_path (optional):\n            The path to the cache file. Defaults to \".bolig_ping_cache\".\n    \"\"\"\n    homes = remove_cached_homes(homes=homes, emails=emails, cache_path=cache_path)\n    for email in emails:\n        added_homes: set[tuple[str, str]] = set()\n        with cache_path.open(\"a\") as file:\n            for home in homes:\n                home_id = home.url.split(\"/\")[-1]\n                if (home_id, email) in added_homes:\n                    continue\n                home_json = json.dumps(dict(id=home_id, email=email))\n                file.write(f\"{home_json}\\n\")\n                added_homes.add((home_id, email))\n\n\ndef remove_cached_homes(docs\n    homes: list[Home], emails: list[str], cache_path: Path = Path(\".bolig_ping_cache\")\n) -&gt; list[Home]:\n    \"\"\"Remove the cached homes from the list of homes.\n\n    Args:\n        homes:\n            The homes to remove the cached homes from.\n        emails:\n            The receiver(s) of the homes.\n        cache_path (optional):\n            The path to the cache file. Defaults to \".bolig_ping_cache\".\n\n    Returns:\n        The homes without the cached homes.\n    \"\"\"\n    cache_path.touch(exist_ok=True)\n    with cache_path.open() as file:\n        for line in file:\n            json_data = json.loads(line)\n            if any(json_data[\"email\"] == email for email in emails):\n                homes = [\n                    home for home in homes if home.url.split(\"/\")[-1] != json_data[\"id\"]\n                ]\n    return homes\n</code></pre>"},{"location":"api/bolig_ping/cli/","title":"bolig_ping.cli","text":"bolig_ping.cli<p> source module bolig_ping.cli </p> <p>Command line interface for the project.</p> <p> Functions </p> <ul> <li> <p>main \u2014 Search for homes in Denmark.</p> </li> </ul> <p> source main(city: list[str], min_price: int | None, max_price: int | None, min_monthly_fee: int | None, max_monthly_fee: int | None, min_rooms: int | None, max_rooms: int | None, min_size: int | None, max_size: int | None, query: list[str], property_type: list[str] | None, email: list[str], cache: bool) \u2192 None </p> <p>Search for homes in Denmark.</p>"},{"location":"src/bolig_ping/cli/","title":"bolig_ping.cli","text":"bolig_ping.cli<p> docs module bolig_ping.cli </p> <pre><code>\"\"\"Command line interface for the project.\"\"\"\n\nimport logging\nimport os\nfrom pathlib import Path\n\nimport click\nfrom dotenv import load_dotenv\n\nfrom .cache import remove_cached_homes, store_to_cache\nfrom .data_models import SearchQuery\nfrom .email import compose_email, send_emails\nfrom .filtering import filter_results\nfrom .scraper import scrape_results\n\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s \u22c5 %(message)s\", datefmt=\"%Y-%m-%d %H:%M:%S\"\n)\nlogger = logging.getLogger(__package__)\n\nload_dotenv(dotenv_path=\".env\")\n\n\n@click.command(\"bolig_ping\")\n@click.option(\n    \"--city\", \"-c\", type=str, multiple=True, help=\"The city to search for homes in.\"\n)\n@click.option(\n    \"--min-price\", type=int, default=None, help=\"The minimum price of the home, in DKK.\"\n)\n@click.option(\n    \"--max-price\", type=int, default=None, help=\"The maximum price of the home, in DKK.\"\n)\n@click.option(\n    \"--min-monthly-fee\",\n    type=int,\n    default=None,\n    help=\"The minimum monthly fee of the home, in DKK.\",\n)\n@click.option(\n    \"--max-monthly-fee\",\n    type=int,\n    default=None,\n    help=\"The maximum monthly fee of the home, in DKK.\",\n)\n@click.option(\n    \"--min-rooms\",\n    type=int,\n    default=None,\n    help=\"The minimum number of rooms in the home.\",\n)\n@click.option(\n    \"--max-rooms\",\n    type=int,\n    default=None,\n    help=\"The maximum number of rooms in the home.\",\n)\n@click.option(\n    \"--min-size\",\n    type=int,\n    default=None,\n    help=\"The minimum size of the home, in square meters.\",\n)\n@click.option(\n    \"--max-size\",\n    type=int,\n    default=None,\n    help=\"The maximum size of the home, in square meters.\",\n)\n@click.option(\n    \"--query\",\n    \"-q\",\n    type=str,\n    multiple=True,\n    help=\"A keyword that the property description must contain.\",\n)\n@click.option(\n    \"--property-type\",\n    \"-t\",\n    type=click.Choice(\n        [\"ejerlejlighed\", \"andelslejlighed\", \"house\"], case_sensitive=False\n    ),\n    multiple=True,\n    default=None,\n    help=\"The type of property to search for.\",\n)\n@click.option(\n    \"--email\",\n    \"-e\",\n    type=str,\n    multiple=True,\n    help=\"Email address to send the notification to. Leave empty to print directly to \"\n    \"the console.\",\n)\n@click.option(\n    \"--cache/--no-cache\",\n    default=True,\n    show_default=True,\n    help=\"Whether to cache the homes that are found.\",\n)\ndef main(docs\n    city: list[str],\n    min_price: int | None,\n    max_price: int | None,\n    min_monthly_fee: int | None,\n    max_monthly_fee: int | None,\n    min_rooms: int | None,\n    max_rooms: int | None,\n    min_size: int | None,\n    max_size: int | None,\n    query: list[str],\n    property_type: list[str] | None,\n    email: list[str],\n    cache: bool,\n) -&gt; None:\n    \"\"\"Search for homes in Denmark.\"\"\"\n    # Check if the required environment variables are set\n    if email and \"GMAIL_EMAIL\" not in os.environ:\n        logger.error(\n            \"GMAIL_EMAIL environment variable is not set. Please set it to your \"\n            \"Gmail email address.\"\n        )\n        return\n    if email and \"GMAIL_PASSWORD\" not in os.environ:\n        logger.error(\n            \"GMAIL_PASSWORD environment variable is not set. Please set it to your \"\n            \"Gmail app password.\"\n        )\n        return\n\n    # Backwards compatibility of cache name\n    old_cache_path = Path(\".boligping_cache\")\n    new_cache_path = Path(\".bolig_ping_cache\")\n    if old_cache_path.exists() and not new_cache_path.exists():\n        old_cache_path.rename(new_cache_path)\n        logger.warning(\n            \"Renamed the cache file from `.boligping_cache` to `.bolig_ping_cache`.\"\n        )\n\n    search_query = SearchQuery(\n        cities=[c.replace(\"-\", \" \").lower() for c in city],\n        min_price=min_price,\n        max_price=max_price,\n        min_monthly_fee=min_monthly_fee,\n        max_monthly_fee=max_monthly_fee,\n        min_rooms=min_rooms,\n        max_rooms=max_rooms,\n        min_size=min_size,\n        max_size=max_size,\n        queries=query,\n        property_type=property_type,\n    )\n\n    if search_query.is_empty():\n        logger.warning(\n            \"No search filters provided. This will return all homes in Denmark! If \"\n            \"this is not what you want, please provide an additional argument. See all \"\n            \"the arguments with `bolig-ping --help`.\"\n        )\n\n    homes = scrape_results(search_query=search_query)\n    if homes is None:\n        logger.warning(\"No results found. Double check your search query.\")\n        return\n\n    if cache:\n        homes = remove_cached_homes(homes=homes, emails=email or [\"no-email\"])\n        store_to_cache(homes=homes, emails=email or [\"no-email\"])\n\n    homes = filter_results(homes=homes, search_query=search_query)\n    logger.info(f\"Found {len(homes)} new homes that satisfy the search query.\")\n\n    if homes:\n        if email:\n            subject, contents = compose_email(homes=homes)\n            send_emails(\n                from_email=os.environ[\"GMAIL_EMAIL\"],\n                password=os.environ[\"GMAIL_PASSWORD\"],\n                to_emails=email,\n                subject=subject,\n                contents=contents,\n            )\n            logger.info(f\"Sent the homes to {email}.\")\n        else:\n            logger.info(\n                \"No email provided, so printing the homes here:\\n\\n\"\n                + \"\\n\\n\".join(home.to_text() for home in homes)\n            )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"api/bolig_ping/data_models/","title":"bolig_ping.data_models","text":"bolig_ping.data_models<p> source module bolig_ping.data_models </p> <p>Data models used in the project.</p> <p> Classes </p> <ul> <li> <p>SearchQuery \u2014 A search query.</p> </li> <li> <p>Home \u2014 A property listing.</p> </li> </ul> <p> source class SearchQuery(**data: Any) </p> <p>Bases : BaseModel</p> <p>A search query.</p> <p>Create a new model by parsing and validating input data from keyword arguments.</p> <p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> <p> Attributes </p> <ul> <li> <p>model_config :  ClassVar[ConfigDict] \u2014 Configuration for the model, should be a dictionary conforming to [<code>ConfigDict</code>][pydantic.config.ConfigDict].</p> </li> <li> <p>model_extra :  dict[str, Any] | None \u2014 Get extra fields set during validation.</p> </li> <li> <p>model_fields_set :  set[str] \u2014 Returns the set of fields that have been explicitly set on this model instance.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>is_empty \u2014 Check if the search query is empty.</p> </li> <li> <p>get_url \u2014 Get the URL for the search query.</p> </li> </ul> <p> source method SearchQuery.is_empty() \u2192 bool </p> <p>Check if the search query is empty.</p> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the search query is empty, False otherwise.</p> </li> </ul> <p> source method SearchQuery.get_url(page: int = 1) \u2192 str </p> <p>Get the URL for the search query.</p> <p> Parameters </p> <ul> <li> <p>page :  optional \u2014 The page number to get the URL for. Defaults to 1.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The URL for the search query.</p> </li> </ul> <p> source class Home(**data: Any) </p> <p>Bases : BaseModel</p> <p>A property listing.</p> <p>Create a new model by parsing and validating input data from keyword arguments.</p> <p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> <p> Attributes </p> <ul> <li> <p>model_config :  ClassVar[ConfigDict] \u2014 Configuration for the model, should be a dictionary conforming to [<code>ConfigDict</code>][pydantic.config.ConfigDict].</p> </li> <li> <p>model_extra :  dict[str, Any] | None \u2014 Get extra fields set during validation.</p> </li> <li> <p>model_fields_set :  set[str] \u2014 Returns the set of fields that have been explicitly set on this model instance.</p> </li> <li> <p>description :  str | None \u2014 Get the description of the home.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>to_html \u2014 Get the home as an HTML string.</p> </li> <li> <p>to_text \u2014 Get the home as a text string.</p> </li> </ul> <p> source property Home.description: str | None </p> <p>Get the description of the home.</p> <p> Returns </p> <ul> <li> <p>str | None \u2014 The description of the home, or None if not available.</p> </li> </ul> <p> source method Home.to_html() \u2192 str </p> <p>Get the home as an HTML string.</p> <p> Returns </p> <ul> <li> <p>str \u2014 The home as an HTML string.</p> </li> </ul> <p> source method Home.to_text() \u2192 str </p> <p>Get the home as a text string.</p> <p> Returns </p> <ul> <li> <p>str \u2014 The home as a text string.</p> </li> </ul>"},{"location":"src/bolig_ping/data_models/","title":"bolig_ping.data_models","text":"bolig_ping.data_models<p> docs module bolig_ping.data_models </p> <pre><code>\"\"\"Data models used in the project.\"\"\"\n\nimport logging\nfrom functools import cached_property\n\nimport requests\nfrom bs4 import BeautifulSoup\nfrom pydantic import BaseModel, Field\n\nlogger = logging.getLogger(__package__)\n\n\nclass SearchQuery(BaseModel):docs\n    \"\"\"A search query.\"\"\"\n\n    cities: list[str] = Field(default_factory=list)\n    min_price: int | None = Field(default=None, ge=0)\n    max_price: int | None = Field(default=None, ge=0)\n    min_monthly_fee: int | None = Field(default=None, ge=0)\n    max_monthly_fee: int | None = Field(default=None, ge=0)\n    min_rooms: int | None = Field(default=None, ge=1)\n    max_rooms: int | None = Field(default=None, ge=1)\n    min_size: int | None = Field(default=None, ge=1)\n    max_size: int | None = Field(default=None, ge=1)\n    queries: list[str] = Field(default_factory=list)\n    property_type: list[str] | None = Field(default=None)\n\n    def is_empty(self) -&gt; bool:docs\n        \"\"\"Check if the search query is empty.\n\n        Returns:\n            True if the search query is empty, False otherwise.\n        \"\"\"\n        return (\n            not self.cities\n            and self.min_price is None\n            and self.max_price is None\n            and self.min_rooms is None\n            and self.max_rooms is None\n            and self.min_size is None\n            and self.max_size is None\n        )\n\n    def get_url(self, page: int = 1) -&gt; str:docs\n        \"\"\"Get the URL for the search query.\n\n        Args:\n            page (optional):\n                The page number to get the URL for. Defaults to 1.\n\n        Returns:\n            The URL for the search query.\n        \"\"\"\n        url = f\"https://api.boligsiden.dk/search/cases?page={page}\"\n\n        property_type_names: list[str] = []\n        if self.property_type is not None:\n            if \"ejerlejlighed\" in self.property_type:\n                property_type_names.extend([\"condo\", \"villa apartment\"])\n            if \"andelslejlighed\" in self.property_type:\n                property_type_names.append(\"cooperative\")\n            if \"house\" in self.property_type:\n                property_type_names.extend([\"terraced house\", \"villa\", \"farm\"])\n            property_type_names = sorted(set(property_type_names))\n\n        arguments: dict[str, str | int | None] = dict(\n            addressTypes=\",\".join(property_type_names) if property_type_names else None,\n            cities=\",\".join(self.cities) if self.cities else None,\n            priceMin=self.min_price,\n            priceMax=self.max_price,\n            numberOfRoomsMin=self.min_rooms,\n            numberOfRoomsMax=self.max_rooms,\n            areaMin=self.min_size,\n            areaMax=self.max_size,\n            monthlyExpenseMin=self.min_monthly_fee,\n            monthlyExpenseMax=self.max_monthly_fee,\n        )\n        non_trivial_arguments = {\n            key: value for key, value in arguments.items() if value is not None\n        }\n        if non_trivial_arguments:\n            url += \"&amp;\" + \"&amp;\".join(\n                f\"{key}={value}\" for key, value in non_trivial_arguments.items()\n            )\n\n        return url\n\n\nclass Home(BaseModel):docs\n    \"\"\"A property listing.\"\"\"\n\n    url: str\n    address: str\n    price: int | None = Field(default=None, ge=0)\n    num_rooms: int | None = Field(default=None, ge=1)\n    size: int | None = Field(default=None, ge=1)\n    monthly_fee: int | None = Field(default=None, ge=0)\n    year: int | None = Field(default=None, ge=0)\n\n    @cached_property\n    def description(self) -&gt; str | None:docs\n        \"\"\"Get the description of the home.\n\n        Returns:\n            The description of the home, or None if not available.\n        \"\"\"\n        response = requests.get(url=self.url)\n        if response.ok:\n            soup = BeautifulSoup(response.content, \"html.parser\")\n            lines = soup.text.split(\"\\n\")\n            long_lines = [line.strip() for line in lines if len(line.strip()) &gt; 200]\n            if long_lines:\n                return \"\\n\".join(long_lines)\n            else:\n                logger.warning(\n                    f\"Could not find description for property {self.url}. The longest \"\n                    f\"line was {max(len(line) for line in lines)} characters long.\"\n                )\n        return None\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Get the hash of the home.\n\n        Returns:\n            The hash of the home.\n        \"\"\"\n        return hash(self.url)\n\n    def to_html(self) -&gt; str:docs\n        \"\"\"Get the home as an HTML string.\n\n        Returns:\n            The home as an HTML string.\n        \"\"\"\n        components = [f\"&lt;a href='{self.url}'&gt;{self.address}&lt;/a&gt;\"]\n        if self.price is not None:\n            components.append(f\"Price: {self.price:,} kr.\")\n        if self.num_rooms is not None:\n            components.append(f\"Number of rooms: {self.num_rooms}\")\n        if self.size is not None:\n            components.append(f\"Size: {self.size} m\u00b2\")\n        if self.monthly_fee is not None:\n            components.append(f\"Monthly fee: {self.monthly_fee:,} kr./md\")\n        if self.year is not None:\n            components.append(f\"Year built: {self.year}\")\n        return \"\\n\".join(components)\n\n    def to_text(self) -&gt; str:docs\n        \"\"\"Get the home as a text string.\n\n        Returns:\n            The home as a text string.\n        \"\"\"\n        components = [f\"URL: {self.url}\", f\"Address: {self.address}\"]\n        if self.price is not None:\n            components.append(f\"Price: {self.price:,} kr.\")\n        if self.num_rooms is not None:\n            components.append(f\"Number of rooms: {self.num_rooms}\")\n        if self.size is not None:\n            components.append(f\"Size: {self.size} m\u00b2\")\n        if self.monthly_fee is not None:\n            components.append(f\"Monthly fee: {self.monthly_fee:,} kr./md\")\n        if self.year is not None:\n            components.append(f\"Year built: {self.year}\")\n        return \"\\n\".join(components)\n</code></pre>"},{"location":"api/bolig_ping/email/","title":"bolig_ping.email","text":"bolig_ping.email<p> source module bolig_ping.email </p> <p>Sending emails with home listings.</p> <p> Functions </p> <ul> <li> <p>compose_email \u2014 Compose an email with the given homes.</p> </li> <li> <p>send_emails \u2014 Send an email with the given contents.</p> </li> </ul> <p> source compose_email(homes: list[Home]) \u2192 tuple[str, str] </p> <p>Compose an email with the given homes.</p> <p> Parameters </p> <ul> <li> <p>homes :  list[Home] \u2014 The homes to compose the email with.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[str, str] \u2014 A pair (subject, contents) for the email.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source send_emails(from_email: str, password: str, to_emails: list[str], subject: str, contents: str) \u2192 None </p> <p>Send an email with the given contents.</p> <p> Parameters </p> <ul> <li> <p>from_email :  str \u2014 The email to send the email from.</p> </li> <li> <p>password :  str \u2014 The password for the from email.</p> </li> <li> <p>to_emails :  list[str] \u2014 The emails to send the email to.</p> </li> <li> <p>subject :  str \u2014 The subject of the email.</p> </li> <li> <p>contents :  str \u2014 The contents of the email.</p> </li> </ul>"},{"location":"src/bolig_ping/email/","title":"bolig_ping.email","text":"bolig_ping.email<p> docs module bolig_ping.email </p> <pre><code>\"\"\"Sending emails with home listings.\"\"\"\n\nimport yagmail\n\nfrom .data_models import Home\n\n\ndef compose_email(homes: list[Home]) -&gt; tuple[str, str]:docs\n    \"\"\"Compose an email with the given homes.\n\n    Args:\n        homes:\n            The homes to compose the email with.\n\n    Returns:\n        A pair (subject, contents) for the email.\n    \"\"\"\n    match len(homes):\n        case 0:\n            raise ValueError(\"Cannot compose an email with no homes.\")\n        case 1:\n            subject = \"[BoligPing] Found a new home!\"\n            contents = \"Hi,\\n\\nI found a new home that you might be interested in:\\n\\n\"\n        case _:\n            subject = f\"[BoligPing] Found {len(homes)} new homes!\"\n            contents = (\n                \"Hi,\\n\\nI found some new homes that you might be interested in:\\n\\n\"\n            )\n    contents += \"\\n\\n\".join(home.to_html() for home in homes)\n    contents += \"\\n\\nHave a splendid day!\\n\\nBest regards,\\nBoligPing\"\n    return subject, contents\n\n\ndef send_emails(docs\n    from_email: str, password: str, to_emails: list[str], subject: str, contents: str\n) -&gt; None:\n    \"\"\"Send an email with the given contents.\n\n    Args:\n        from_email:\n            The email to send the email from.\n        password:\n            The password for the from email.\n        to_emails:\n            The emails to send the email to.\n        subject:\n            The subject of the email.\n        contents:\n            The contents of the email.\n    \"\"\"\n    for to_email in to_emails:\n        yagmail.SMTP(user=from_email, password=password).send(\n            to=to_email, subject=subject, contents=contents\n        )\n</code></pre>"},{"location":"api/bolig_ping/filtering/","title":"bolig_ping.filtering","text":"bolig_ping.filtering<p> source module bolig_ping.filtering </p> <p>Filtering of scraped results.</p> <p> Functions </p> <ul> <li> <p>filter_results \u2014 Filter the homes based on the given criteria.</p> </li> </ul> <p> source filter_results(homes: list[Home], search_query: SearchQuery) \u2192 list[Home] </p> <p>Filter the homes based on the given criteria.</p> <p> Parameters </p> <ul> <li> <p>homes :  list[Home] \u2014 The homes to filter.</p> </li> <li> <p>search_query :  SearchQuery \u2014 The search query to filter the homes by.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[Home] \u2014 The filtered homes.</p> </li> </ul>"},{"location":"src/bolig_ping/filtering/","title":"bolig_ping.filtering","text":"bolig_ping.filtering<p> docs module bolig_ping.filtering </p> <pre><code>\"\"\"Filtering of scraped results.\"\"\"\n\nfrom tqdm.auto import tqdm\n\nfrom .data_models import Home, SearchQuery\n\ndocs\ndef filter_results(homes: list[Home], search_query: SearchQuery) -&gt; list[Home]:\n    \"\"\"Filter the homes based on the given criteria.\n\n    Args:\n        homes:\n            The homes to filter.\n        search_query:\n            The search query to filter the homes by.\n\n    Returns:\n        The filtered homes.\n    \"\"\"\n    # Filter the homes based on the monthly fee\n    homes = [\n        home\n        for home in homes\n        if home.monthly_fee is None\n        or (\n            (\n                search_query.min_monthly_fee is None\n                or home.monthly_fee &gt;= search_query.min_monthly_fee\n            )\n            and (\n                search_query.max_monthly_fee is None\n                or home.monthly_fee &lt;= search_query.max_monthly_fee\n            )\n        )\n    ]\n\n    # Filter the homes if any keyword queries were given\n    if search_query.queries:\n        homes = [\n            home\n            for home in tqdm(iterable=homes, desc=\"Filtering homes based on keywords\")\n            if home.description is not None\n            and any(\n                query.lower() in home.description.lower()\n                for query in search_query.queries\n            )\n        ]\n\n    return homes\n</code></pre>"},{"location":"api/bolig_ping/scraper/","title":"bolig_ping.scraper","text":"bolig_ping.scraper<p> source module bolig_ping.scraper </p> <p>Scraping homes available satisfying the given criteria.</p> <p> Functions </p> <ul> <li> <p>scrape_results \u2014 Scrape the results of a home search query.</p> </li> <li> <p>get_home_from_result \u2014 Get a home from a result.</p> </li> </ul> <p> source scrape_results(search_query: SearchQuery) \u2192 list[Home] | None </p> <p>Scrape the results of a home search query.</p> <p> Parameters </p> <ul> <li> <p>search_query :  SearchQuery \u2014 The search query to scrape results for.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[Home] | None \u2014 A list of homes that satisfy the search query, or None if no results were found.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>HTTPError \u2014 If there was an error in the HTTP request.</p> </li> </ul> <p> source get_home_from_result(result: dict) \u2192 Home </p> <p>Get a home from a result.</p> <p> Parameters </p> <ul> <li> <p>result :  dict \u2014 The result to get the home from.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Home \u2014 The home from the result.</p> </li> </ul>"},{"location":"src/bolig_ping/scraper/","title":"bolig_ping.scraper","text":"bolig_ping.scraper<p> docs module bolig_ping.scraper </p> <pre><code>\"\"\"Scraping homes available satisfying the given criteria.\"\"\"\n\nimport json\nimport logging\n\nimport requests\nfrom tqdm.auto import tqdm\n\nfrom .data_models import Home, SearchQuery\n\nlogger = logging.getLogger(__package__)\n\n\ndef scrape_results(search_query: SearchQuery) -&gt; list[Home] | None:docs\n    \"\"\"Scrape the results of a home search query.\n\n    Args:\n        search_query:\n            The search query to scrape results for.\n\n    Returns:\n        A list of homes that satisfy the search query, or None if no results were found.\n\n    Raises:\n        HTTPError:\n            If there was an error in the HTTP request.\n    \"\"\"\n    logger.info(\"Fetching results...\")\n\n    # Get the results from the search query\n    url = search_query.get_url()\n    response = requests.get(url=url)\n    response.raise_for_status()\n\n    # Parse the response\n    result_dict = json.loads(response.text)\n    results = result_dict[\"cases\"]\n    if results is None:\n        return None\n\n    # Get the number of pages\n    num_results = result_dict[\"totalHits\"]\n    num_pages = num_results // len(results)\n    if num_results % len(results) != 0:\n        num_pages += 1\n\n    # Get the first page of results\n    homes = [get_home_from_result(result=result) for result in results]\n\n    # Scrape the remaining pages\n    if num_pages &gt; 1:\n        with tqdm(desc=\"Scraping homes from boligsiden.dk\", total=num_results) as pbar:\n            pbar.update(len(homes))\n            for page_idx in range(2, num_pages + 1):\n                url = search_query.get_url(page=page_idx)\n                response = requests.get(url=url)\n                response.raise_for_status()\n                result_dict = json.loads(response.text)\n                results = result_dict[\"cases\"]\n                new_homes = [get_home_from_result(result=result) for result in results]\n                homes.extend(new_homes)\n                homes = list(set(homes))\n                pbar.update(len(new_homes))\n\n        # Ensure that the progress bar is at 100% at the end\n        pbar.n = pbar.total\n\n    return homes\n\n\ndef get_home_from_result(result: dict) -&gt; Home:docs\n    \"\"\"Get a home from a result.\n\n    Args:\n        result:\n            The result to get the home from.\n\n    Returns:\n        The home from the result.\n    \"\"\"\n    url = f\"https://boligsiden.dk/viderestilling/{result['caseID']}\"\n    road_name = result[\"address\"][\"roadName\"]\n    road_number = result[\"address\"].get(\"houseNumber\")\n    floor = result[\"address\"].get(\"floor\")\n    door = result[\"address\"].get(\"door\")\n    post_code = result[\"address\"].get(\"zipCode\")\n    city = result[\"address\"][\"cityName\"]\n\n    address = road_name\n    if road_number:\n        address += f\" {road_number}\"\n    if floor:\n        floor = floor.replace(\"0\", \"st.\")\n        address += f\" {floor}\"\n    if door:\n        address += f\" {door}\"\n    if post_code:\n        address += f\" {post_code}\"\n    if city:\n        address += f\" {city}\"\n\n    return Home(\n        url=url,\n        address=address,\n        price=result.get(\"priceCash\"),\n        num_rooms=result.get(\"numberOfRooms\"),\n        size=result.get(\"housingArea\"),\n        monthly_fee=result.get(\"monthlyExpense\"),\n        year=result.get(\"yearBuilt\"),\n    )\n</code></pre>"}]}