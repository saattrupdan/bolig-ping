{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bolig Ping","text":"<p>Get a ping when your dream home in Denmark becomes available on Boligsiden.dk.</p> <p> </p> <p>Developer:</p> <ul> <li>Dan Saattrup Nielsen (saattrupdan@gmail.com)</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>The easiest way to use the package is as a uv tool. You can simply start searching for properties using the following command:</p> <pre><code>uvx bolig-ping --city k\u00f8benhavn\n</code></pre> <p>This both installs the package and runs the command. All the available options are listed below, but you can always get these by running the following command:</p> <pre><code>uvx bolig-ping --help\n</code></pre> <p>To be able to send emails, you have to create a Google app password, and store both your Gmail email address and the app password in the environment variables <code>GMAIL_EMAIL</code> and <code>GMAIL_PASSWORD</code>, respectively. You can also simply store these in a <code>.env</code> file, as follows:</p> <pre><code>GMAIL_EMAIL=&lt;your-email&gt;@gmail.com\nGMAIL_PASSWORD=&lt;your-app-password&gt;\n</code></pre> <p>With this set up, you can now use the <code>--email</code> option to receive an email with new properties that match your search criteria:</p> <pre><code>uvx bolig-ping --city k\u00f8benhavn --email &lt;your-email&gt;\n</code></pre> <p>You can also set up a recurring search if you have a server available. In this case, you can add the following line to your crontab on a server, to run the search every hour:</p> <pre><code>0 * * * * &lt;uvx-full-path&gt; bolig-ping &lt;search-arguments&gt;\n</code></pre> <p>Here <code>&lt;uvx-full-path&gt;</code> is the full path to the <code>uvx</code> command, which you can find by running <code>which uvx</code> in your terminal.</p>"},{"location":"#all-options","title":"All options","text":"<p>The following options are available:</p> <ul> <li><code>--city/-c</code> (required): The city you want to search in. This argument can be   used several times to search in multiple cities, e.g., <code>-c aarhus -c odense</code>.</li> <li><code>--min-price</code>: The minimum price of the property, in DKK. Default is no minimum price.</li> <li><code>--max-price</code>: The maximum price of the property, in DKK. Default is no maximum price.</li> <li><code>--min-monthly-fee</code>: The minimum monthly fee of the property, in DKK. Default is no   minimum monthly fee.</li> <li><code>--max-monthly-fee</code>: The maximum monthly fee of the property, in DKK. Default is no   maximum monthly fee.</li> <li><code>--min-rooms</code>: The minimum number of rooms in the property. Default is no minimum   number of rooms.</li> <li><code>--max-rooms</code>: The maximum number of rooms in the property. Default is no maximum   number of rooms.</li> <li><code>--min-size</code>: The minimum size of the property, in square meters. Default is no   minimum size.</li> <li><code>--max-size</code>: The maximum size of the property, in square meters. Default is no   maximum size.</li> <li><code>--query/-q</code>: The query to search for in the property description. This argument can   be used several times to search for multiple queries, e.g., <code>-q badekar -q altan</code>.</li> <li><code>--property-type/-t</code>: The type of property to search for. The available property   types are <code>ejerlejlighed</code>, <code>andelslejlighed</code> and <code>house</code>. This argument can be used   several times to search for multiple property types, e.g., <code>-t ejerlejlighed -t house</code>.   Default is only searching for <code>ejerlejlighed</code>.</li> <li><code>--email</code>: The email address you want to receive the ping on. Note that this needs to   have the <code>GMAIL_EMAIL</code> and <code>GMAIL_PASSWORD</code> environment variables set, as described   above. Default is to use no email address, and instead print the properties to the   console.</li> <li><code>--cache/--no-cache</code>: Whether to use the cache or not. Default is to use the cache,   but you can disable it by using the <code>--no-cache</code> flag. This is useful if you want to   see all the results, and not just the new ones. The cache is stored in the   <code>.boligping_cache</code> file in the current directory.</li> </ul>"},{"location":"api/bolig_ping/","title":"bolig_ping","text":"bolig_ping<p> source package bolig_ping </p> <p>Get a ping when your dream home becomes available.</p> <p> Modules </p> <ul> <li> <p>bolig_ping.cache \u2014 Cache to store already sent homes.</p> </li> <li> <p>bolig_ping.cli \u2014 Command line interface for the project.</p> </li> <li> <p>bolig_ping.data_models \u2014 Data models used in the project.</p> </li> <li> <p>bolig_ping.email \u2014 Sending emails with home listings.</p> </li> <li> <p>bolig_ping.scraper \u2014 Scraping homes available satisfying the given criteria.</p> </li> <li> <p>bolig_ping.webdriver \u2014 Webdriver used for scraping.</p> </li> </ul>"},{"location":"src/bolig_ping/","title":"bolig_ping","text":"bolig_ping<p> docs package bolig_ping </p> <pre><code>\"\"\"Get a ping when your dream home becomes available.\"\"\"\n</code></pre>"},{"location":"api/bolig_ping/cache/","title":"bolig_ping.cache","text":"bolig_ping.cache<p> source module bolig_ping.cache </p> <p>Cache to store already sent homes.</p> <p> Functions </p> <ul> <li> <p>store_to_cache \u2014 Store the homes to the cache.</p> </li> <li> <p>remove_cached_homes \u2014 Remove the cached homes from the list of homes.</p> </li> </ul> <p> source store_to_cache(homes: list[Home], email: str, cache_path: Path = Path('.boligping_cache')) \u2192 None </p> <p>Store the homes to the cache.</p> <p> Parameters </p> <ul> <li> <p>homes :  list[Home] \u2014 The homes to store in the cache.</p> </li> <li> <p>email :  str \u2014 The receiver of the homes.</p> </li> <li> <p>cache_path :  optional \u2014 The path to the cache file. Defaults to \".boligping_cache\".</p> </li> </ul> <p> source remove_cached_homes(homes: list[Home], email: str, cache_path: Path = Path('.boligping_cache')) \u2192 list[Home] </p> <p>Remove the cached homes from the list of homes.</p> <p> Parameters </p> <ul> <li> <p>homes :  list[Home] \u2014 The homes to remove the cached homes from.</p> </li> <li> <p>email :  str \u2014 The receiver of the homes.</p> </li> <li> <p>cache_path :  optional \u2014 The path to the cache file. Defaults to \".boligping_cache\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[Home] \u2014 The homes without the cached homes.</p> </li> </ul>"},{"location":"src/bolig_ping/cache/","title":"bolig_ping.cache","text":"bolig_ping.cache<p> docs module bolig_ping.cache </p> <pre><code>\"\"\"Cache to store already sent homes.\"\"\"\n\nimport json\nfrom pathlib import Path\n\nfrom .data_models import Home\n\n\ndef store_to_cache(docs\n    homes: list[Home], email: str, cache_path: Path = Path(\".boligping_cache\")\n) -&gt; None:\n    \"\"\"Store the homes to the cache.\n\n    Args:\n        homes:\n            The homes to store in the cache.\n        email:\n            The receiver of the homes.\n        cache_path (optional):\n            The path to the cache file. Defaults to \".boligping_cache\".\n    \"\"\"\n    homes = remove_cached_homes(homes=homes, email=email, cache_path=cache_path)\n    added_homes: set[tuple[str, str]] = set()\n    with cache_path.open(\"a\") as file:\n        for home in homes:\n            home_id = home.url.split(\"/\")[-1]\n            if (home_id, email) in added_homes:\n                continue\n            home_json = json.dumps(dict(id=home_id, email=email))\n            file.write(f\"{home_json}\\n\")\n            added_homes.add((home_id, email))\n\n\ndef remove_cached_homes(docs\n    homes: list[Home], email: str, cache_path: Path = Path(\".boligping_cache\")\n) -&gt; list[Home]:\n    \"\"\"Remove the cached homes from the list of homes.\n\n    Args:\n        homes:\n            The homes to remove the cached homes from.\n        email:\n            The receiver of the homes.\n        cache_path (optional):\n            The path to the cache file. Defaults to \".boligping_cache\".\n\n    Returns:\n        The homes without the cached homes.\n    \"\"\"\n    cache_path.touch(exist_ok=True)\n    with cache_path.open() as file:\n        for line in file:\n            json_data = json.loads(line)\n            if json_data[\"email\"] == email:\n                homes = [\n                    home for home in homes if home.url.split(\"/\")[-1] != json_data[\"id\"]\n                ]\n    return homes\n</code></pre>"},{"location":"api/bolig_ping/cli/","title":"bolig_ping.cli","text":"bolig_ping.cli<p> source module bolig_ping.cli </p> <p>Command line interface for the project.</p> <p> Functions </p> <ul> <li> <p>main \u2014 Search for homes in Denmark.</p> </li> </ul> <p> source main(city: list[str], min_price: int, max_price: int, min_monthly_fee: int, max_monthly_fee: int, min_rooms: int, max_rooms: int, min_size: int, max_size: int, query: list[str], property_type: list[str], email: str | None, cache: bool) \u2192 None </p> <p>Search for homes in Denmark.</p>"},{"location":"src/bolig_ping/cli/","title":"bolig_ping.cli","text":"bolig_ping.cli<p> docs module bolig_ping.cli </p> <pre><code>\"\"\"Command line interface for the project.\"\"\"\n\nimport logging\nimport os\n\nimport click\n\nfrom .cache import remove_cached_homes, store_to_cache\nfrom .data_models import SearchQuery\nfrom .email import compose_email, send_email\nfrom .scraper import scrape_results\n\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s \u22c5 %(message)s\", datefmt=\"%Y-%m-%d %H:%M:%S\"\n)\nlogger = logging.getLogger(__package__)\n\n\n@click.command(\"bolig_ping\")\n@click.option(\n    \"--city\",\n    \"-c\",\n    type=str,\n    multiple=True,\n    required=True,\n    help=\"The city to search for apartments in.\",\n)\n@click.option(\n    \"--min-price\",\n    type=int,\n    default=0,\n    show_default=True,\n    help=\"The minimum price of the apartment, in DKK.\",\n)\n@click.option(\n    \"--max-price\",\n    type=int,\n    default=int(1e9),\n    show_default=True,\n    help=\"The maximum price of the apartment, in DKK.\",\n)\n@click.option(\n    \"--min-monthly-fee\",\n    type=int,\n    default=0,\n    show_default=True,\n    help=\"The minimum monthly fee of the apartment, in DKK.\",\n)\n@click.option(\n    \"--max-monthly-fee\",\n    type=int,\n    default=int(1e9),\n    show_default=True,\n    help=\"The maximum monthly fee of the apartment, in DKK.\",\n)\n@click.option(\n    \"--min-rooms\",\n    type=int,\n    default=1,\n    show_default=True,\n    help=\"The minimum number of rooms in the apartment.\",\n)\n@click.option(\n    \"--max-rooms\",\n    type=int,\n    default=int(1e9),\n    show_default=True,\n    help=\"The maximum number of rooms in the apartment.\",\n)\n@click.option(\n    \"--min-size\",\n    type=int,\n    default=0,\n    show_default=True,\n    help=\"The minimum size of the apartment, in square meters.\",\n)\n@click.option(\n    \"--max-size\",\n    type=int,\n    default=int(1e9),\n    show_default=True,\n    help=\"The maximum size of the apartment, in square meters.\",\n)\n@click.option(\n    \"--query\",\n    \"-q\",\n    multiple=True,\n    help=\"A keyword that the home description must contain.\",\n)\n@click.option(\n    \"--property-type\",\n    \"-t\",\n    type=click.Choice([\"ejerlejlighed\", \"andelslejlighed\", \"house\"]),\n    multiple=True,\n    default=None,\n    help=\"The type of property to search for. Default is only searching for \"\n    \"'ejerlejlighed'.\",\n)\n@click.option(\n    \"--email\",\n    type=str,\n    default=None,\n    show_default=True,\n    help=\"Email address to send the notification to, or None to print to stdout.\",\n)\n@click.option(\n    \"--cache/--no-cache\",\n    default=True,\n    show_default=True,\n    help=\"Whether to cache the homes that are found.\",\n)\ndef main(docs\n    city: list[str],\n    min_price: int,\n    max_price: int,\n    min_monthly_fee: int,\n    max_monthly_fee: int,\n    min_rooms: int,\n    max_rooms: int,\n    min_size: int,\n    max_size: int,\n    query: list[str],\n    property_type: list[str],\n    email: str | None,\n    cache: bool,\n) -&gt; None:\n    \"\"\"Search for homes in Denmark.\"\"\"\n    cities = [\n        c.replace(\" \", \"-\")\n        .replace(\"\u00f8\", \"oe\")\n        .replace(\"\u00e6\", \"ae\")\n        .replace(\"\u00e5\", \"aa\")\n        .lower()\n        for c in city\n    ]\n    search_query = SearchQuery(\n        cities=cities,\n        min_price=min_price,\n        max_price=max_price,\n        min_monthly_fee=min_monthly_fee,\n        max_monthly_fee=max_monthly_fee,\n        min_rooms=min_rooms,\n        max_rooms=max_rooms,\n        min_size=min_size,\n        max_size=max_size,\n        queries=query,\n        property_type=property_type or [\"ejerlejlighed\"],\n    )\n    homes = scrape_results(search_query=search_query)\n    if homes is None:\n        logger.error(\n            \"Could not find the city that you requested. Please double check the \"\n            \"spelling of the city name(s) and try again.\"\n        )\n        return\n    if cache:\n        homes = remove_cached_homes(homes=homes, email=email or \"no-email\")\n\n    logger.info(f\"Found {len(homes)} new homes that satisfy the search query.\")\n\n    if homes:\n        if email is not None:\n            subject, contents = compose_email(homes=homes)\n            send_email(\n                from_email=os.environ[\"GMAIL_EMAIL\"],\n                password=os.environ[\"GMAIL_PASSWORD\"],\n                to_email=email,\n                subject=subject,\n                contents=contents,\n            )\n            logger.info(f\"Sent the homes to {email}.\")\n        else:\n            logger.info(\n                \"No email provided, so printing the homes here:\\n\\n\"\n                + \"\\n\\n\".join(home.to_text() for home in homes)\n            )\n        if cache:\n            store_to_cache(homes=homes, email=email or \"no-email\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"api/bolig_ping/data_models/","title":"bolig_ping.data_models","text":"bolig_ping.data_models<p> source module bolig_ping.data_models </p> <p>Data models used in the project.</p> <p> Classes </p> <ul> <li> <p>SearchQuery \u2014 A search query.</p> </li> <li> <p>Home \u2014 A property listing.</p> </li> </ul> <p> source class SearchQuery(**data: Any) </p> <p>Bases : BaseModel</p> <p>A search query.</p> <p>Create a new model by parsing and validating input data from keyword arguments.</p> <p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> <p> Attributes </p> <ul> <li> <p>model_config :  ClassVar[ConfigDict] \u2014 Configuration for the model, should be a dictionary conforming to [<code>ConfigDict</code>][pydantic.config.ConfigDict].</p> </li> <li> <p>model_extra :  dict[str, Any] | None \u2014 Get extra fields set during validation.</p> </li> <li> <p>model_fields_set :  set[str] \u2014 Returns the set of fields that have been explicitly set on this model instance.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>get_url \u2014 Get the URL for the search query.</p> </li> </ul> <p> source method SearchQuery.get_url() \u2192 str </p> <p>Get the URL for the search query.</p> <p> Returns </p> <ul> <li> <p>str \u2014 The URL for the search query.</p> </li> </ul> <p> source class Home(**data: Any) </p> <p>Bases : BaseModel</p> <p>A property listing.</p> <p>Create a new model by parsing and validating input data from keyword arguments.</p> <p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> <p> Attributes </p> <ul> <li> <p>model_config :  ClassVar[ConfigDict] \u2014 Configuration for the model, should be a dictionary conforming to [<code>ConfigDict</code>][pydantic.config.ConfigDict].</p> </li> <li> <p>model_extra :  dict[str, Any] | None \u2014 Get extra fields set during validation.</p> </li> <li> <p>model_fields_set :  set[str] \u2014 Returns the set of fields that have been explicitly set on this model instance.</p> </li> <li> <p>description :  str | None \u2014 Get the description of the home.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>to_html \u2014 Get the home as an HTML string.</p> </li> <li> <p>to_text \u2014 Get the home as a text string.</p> </li> </ul> <p> source property Home.description: str | None </p> <p>Get the description of the home.</p> <p> Returns </p> <ul> <li> <p>str | None \u2014 The description of the home, or None if not available.</p> </li> </ul> <p> source method Home.to_html() \u2192 str </p> <p>Get the home as an HTML string.</p> <p> Returns </p> <ul> <li> <p>str \u2014 The home as an HTML string.</p> </li> </ul> <p> source method Home.to_text() \u2192 str </p> <p>Get the home as a text string.</p> <p> Returns </p> <ul> <li> <p>str \u2014 The home as a text string.</p> </li> </ul>"},{"location":"src/bolig_ping/data_models/","title":"bolig_ping.data_models","text":"bolig_ping.data_models<p> docs module bolig_ping.data_models </p> <pre><code>\"\"\"Data models used in the project.\"\"\"\n\nimport logging\nfrom functools import cached_property\n\nimport requests\nfrom bs4 import BeautifulSoup\nfrom pydantic import BaseModel\n\nlogger = logging.getLogger(__package__)\n\n\nclass SearchQuery(BaseModel):docs\n    \"\"\"A search query.\"\"\"\n\n    cities: list[str]\n    min_price: int\n    max_price: int\n    min_monthly_fee: int\n    max_monthly_fee: int\n    min_rooms: int\n    max_rooms: int\n    min_size: int\n    max_size: int\n    queries: list[str]\n    property_type: list[str]\n\n    def get_url(self) -&gt; str:docs\n        \"\"\"Get the URL for the search query.\n\n        Returns:\n            The URL for the search query.\n        \"\"\"\n        property_type_names: list[str] = []\n        if \"ejerlejlighed\" in self.property_type:\n            property_type_names.extend([\"ejerlejlighed\", \"villalejlighed\"])\n        if \"andelslejlighed\" in self.property_type:\n            property_type_names.append(\"andelslejlighed\")\n        if \"house\" in self.property_type:\n            property_type_names.extend([\"raekkehus\", \"villa\", \"landejendom\"])\n        property_type_names = sorted(set(property_type_names))\n\n        url = \"https://www.boligsiden.dk/by/{}/tilsalg/{}\".format(\n            \",\".join(self.cities), \",\".join(property_type_names)\n        )\n        arguments: dict[str, str | int] = dict(\n            priceMin=self.min_price,\n            priceMax=self.max_price,\n            numberOfRoomsMin=self.min_rooms,\n            numberOfRoomsMax=self.max_rooms,\n            areaMin=self.min_size,\n            areaMax=self.max_size,\n        )\n        url += \"?\" + \"&amp;\".join(f\"{key}={value}\" for key, value in arguments.items())\n        return url\n\n\nclass Home(BaseModel):docs\n    \"\"\"A property listing.\"\"\"\n\n    url: str\n    address: str\n    price: int | None\n    num_rooms: int | None\n    size: int | None\n    monthly_fee: int | None\n    year: int | None\n\n    @cached_property\n    def description(self) -&gt; str | None:docs\n        \"\"\"Get the description of the home.\n\n        Returns:\n            The description of the home, or None if not available.\n        \"\"\"\n        response = requests.get(url=self.url)\n        if response.ok:\n            soup = BeautifulSoup(response.content, \"html.parser\")\n            lines = soup.text.split(\"\\n\")\n            long_lines = [line.strip() for line in lines if len(line.strip()) &gt; 200]\n            if long_lines:\n                return \"\\n\".join(long_lines)\n            else:\n                logger.warning(\n                    f\"Could not find description for property {self.url}. The longest \"\n                    f\"line was {max(len(line) for line in lines)} characters long.\"\n                )\n        return None\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Get the hash of the home.\n\n        Returns:\n            The hash of the home.\n        \"\"\"\n        return hash(self.url)\n\n    def to_html(self) -&gt; str:docs\n        \"\"\"Get the home as an HTML string.\n\n        Returns:\n            The home as an HTML string.\n        \"\"\"\n        html = \"\\n\".join(\n            [\n                f\"&lt;a href='{self.url}'&gt;{self.address}&lt;/a&gt;\",\n                f\"Price: {self.price:,} kr.\",\n                f\"Number of rooms: {self.num_rooms}\",\n                f\"Size: {self.size} m\u00b2\",\n                f\"Monthly fee: {self.monthly_fee:,} kr./md\",\n                f\"Year built: {self.year}\",\n            ]\n        )\n        return html\n\n    def to_text(self) -&gt; str:docs\n        \"\"\"Get the home as a text string.\n\n        Returns:\n            The home as a text string.\n        \"\"\"\n        text = \"\\n\".join(\n            [\n                f\"URL: {self.url}\",\n                f\"Address: {self.address}\",\n                f\"Price: {self.price:,} kr.\",\n                f\"Number of rooms: {self.num_rooms}\",\n                f\"Size: {self.size} m\u00b2\",\n                f\"Monthly fee: {self.monthly_fee:,} kr./md\",\n                f\"Year built: {self.year}\",\n            ]\n        )\n        return text\n</code></pre>"},{"location":"api/bolig_ping/email/","title":"bolig_ping.email","text":"bolig_ping.email<p> source module bolig_ping.email </p> <p>Sending emails with home listings.</p> <p> Functions </p> <ul> <li> <p>compose_email \u2014 Compose an email with the given homes.</p> </li> <li> <p>send_email \u2014 Send an email with the given contents.</p> </li> </ul> <p> source compose_email(homes: list[Home]) \u2192 tuple[str, str] </p> <p>Compose an email with the given homes.</p> <p> Parameters </p> <ul> <li> <p>homes :  list[Home] \u2014 The homes to compose the email with.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[str, str] \u2014 A pair (subject, contents) for the email.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source send_email(from_email: str, password: str, to_email: str, subject: str, contents: str) \u2192 None </p> <p>Send an email with the given contents.</p> <p> Parameters </p> <ul> <li> <p>from_email :  str \u2014 The email to send the email from.</p> </li> <li> <p>password :  str \u2014 The password for the from email.</p> </li> <li> <p>to_email :  str \u2014 The email to send the email to.</p> </li> <li> <p>subject :  str \u2014 The subject of the email.</p> </li> <li> <p>contents :  str \u2014 The contents of the email.</p> </li> </ul>"},{"location":"src/bolig_ping/email/","title":"bolig_ping.email","text":"bolig_ping.email<p> docs module bolig_ping.email </p> <pre><code>\"\"\"Sending emails with home listings.\"\"\"\n\nimport yagmail\nfrom dotenv import load_dotenv\n\nfrom .data_models import Home\n\nload_dotenv()\n\n\ndef compose_email(homes: list[Home]) -&gt; tuple[str, str]:docs\n    \"\"\"Compose an email with the given homes.\n\n    Args:\n        homes:\n            The homes to compose the email with.\n\n    Returns:\n        A pair (subject, contents) for the email.\n    \"\"\"\n    match len(homes):\n        case 0:\n            raise ValueError(\"Cannot compose an email with no homes.\")\n        case 1:\n            subject = \"[BoligPing] Found a new home!\"\n            contents = \"Hi,\\n\\nI found a new home that you might be interested in:\\n\\n\"\n        case _:\n            subject = f\"[BoligPing] Found {len(homes)} new homes!\"\n            contents = (\n                \"Hi,\\n\\nI found some new homes that you might be interested in:\\n\\n\"\n            )\n    contents += \"\\n\\n\".join(home.to_html() for home in homes)\n    contents += \"\\n\\nHave a splendid day!\\n\\nBest regards,\\nBoligPing\"\n    return subject, contents\n\n\ndef send_email(docs\n    from_email: str, password: str, to_email: str, subject: str, contents: str\n) -&gt; None:\n    \"\"\"Send an email with the given contents.\n\n    Args:\n        from_email:\n            The email to send the email from.\n        password:\n            The password for the from email.\n        to_email:\n            The email to send the email to.\n        subject:\n            The subject of the email.\n        contents:\n            The contents of the email.\n    \"\"\"\n    yagmail.SMTP(user=from_email, password=password).send(\n        to=to_email, subject=subject, contents=contents\n    )\n</code></pre>"},{"location":"api/bolig_ping/scraper/","title":"bolig_ping.scraper","text":"bolig_ping.scraper<p> source module bolig_ping.scraper </p> <p>Scraping homes available satisfying the given criteria.</p> <p> Functions </p> <ul> <li> <p>scrape_results \u2014 Scrape the results of a home search query.</p> </li> <li> <p>get_home_from_result \u2014 Get a home from a result.</p> </li> <li> <p>extract_number \u2014 Extract the number from a string.</p> </li> </ul> <p> source scrape_results(search_query: SearchQuery) \u2192 list[Home] | None </p> <p>Scrape the results of a home search query.</p> <p> Parameters </p> <ul> <li> <p>search_query :  SearchQuery \u2014 The search query to scrape results for.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[Home] | None \u2014 A list of homes that satisfy the search query, or None if no results were found.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>HTTPError \u2014 If there was an error in the HTTP request.</p> </li> <li> <p>ValueError</p> </li> <li> <p>TimeoutError</p> </li> </ul> <p> source get_home_from_result(result: WebElement) \u2192 Home </p> <p>Get a home from a result.</p> <p> Parameters </p> <ul> <li> <p>result :  WebElement \u2014 The result to get the home from.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Home \u2014 The home from the result.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If the result could not be parsed.</p> </li> </ul> <p> source extract_number(text: str) \u2192 int | None </p> <p>Extract the number from a string.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The string containing the number.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>int | None \u2014 The number, or None if no number was found.</p> </li> </ul>"},{"location":"src/bolig_ping/scraper/","title":"bolig_ping.scraper","text":"bolig_ping.scraper<p> docs module bolig_ping.scraper </p> <pre><code>\"\"\"Scraping homes available satisfying the given criteria.\"\"\"\n\nimport logging\nimport re\n\nfrom selenium.common.exceptions import NoSuchElementException, TimeoutException\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.remote.webelement import WebElement\nfrom tqdm.auto import tqdm\n\nfrom .data_models import Home, SearchQuery\nfrom .webdriver import Webdriver\n\nlogger = logging.getLogger(__package__)\n\n\ndef scrape_results(search_query: SearchQuery) -&gt; list[Home] | None:docs\n    \"\"\"Scrape the results of a home search query.\n\n    Args:\n        search_query:\n            The search query to scrape results for.\n\n    Returns:\n        A list of homes that satisfy the search query, or None if no results were found.\n\n    Raises:\n        HTTPError:\n            If there was an error in the HTTP request.\n    \"\"\"\n    url = search_query.get_url()\n    logger.info(f\"Fetching URL {url!r}...\")\n    webdriver = Webdriver().load(url=url)\n\n    if \"Siden findes ikke\" in webdriver.html:\n        return None\n\n    # Close the cookie banner\n    logger.info(\"Closing cookie banner...\")\n    webdriver.click_element_or_ignore(\n        xpath=\"//button[@id='didomi-notice-disagree-button']\"\n    )\n\n    # Get the number of pages\n    logger.info(\"Getting number of results...\")\n    try:\n        num_results_elt = webdriver.find_element(\n            \"//h1[contains(concat(' ', normalize-space(@class), ' '), ' text-xl ')]\"\n        )\n    except NoSuchElementException:\n        raise ValueError(\n            f\"Could not find number of results for search query: {search_query}\"\n        )\n    except TimeoutException:\n        raise TimeoutError(\n            \"Timed out while trying to fetch number of results for search query: \"\n            f\"{search_query}.\"\n        )\n\n    num_results_match = re.search(r\"[0-9]+\", num_results_elt.text)\n    if num_results_match is None:\n        raise ValueError(\"Could not find number of results.\")\n    num_results = int(num_results_match.group())\n\n    # Extract the homes from the first page\n    logger.info(\"Scraping first page...\")\n    results = webdriver.find_elements(\n        \"//div[@data-testid='case-list-card' and \"\n        \"contains(concat(' ', normalize-space(@class), ' '), ' shadow-card ')]\"\n    )\n    homes = [get_home_from_result(result=result) for result in results]\n\n    # Scrape the remaining pages\n    with tqdm(desc=\"Scraping pages\") as pbar:\n        # Update the progress bar\n        pbar.total = num_results\n        pbar.update(len(homes))\n\n        # Calculate the number of pages\n        num_pages = num_results // 50\n        if num_results % 50 != 0:\n            num_pages += 1\n\n        # Iterate over the remaining pages\n        for _ in range(num_pages - 1):\n            # Go to next page page\n            webdriver.click_element_or_ignore(\n                xpath=\"//ul[@role='navigation']//a[@role='button' and @rel='next']\"\n            )\n\n            # Get the results, where we keep trying in case the page hasn't changed\n            # correctly\n            num_homes = len(homes)\n            new_homes = []\n            num_attempts = 3\n            while len(homes) == num_homes:\n                # Get the results\n                results = webdriver.find_elements(\n                    \"//div[\"\n                    \"@data-testid='case-list-card' and contains(\"\n                    \"concat(' ', normalize-space(@class), ' '), ' shadow-card ')\"\n                    \"]\"\n                )\n                new_homes = [get_home_from_result(result=result) for result in results]\n                homes.extend(new_homes)\n                homes = list(set(homes))\n\n                # Monitor the number of attempts and raise an error if we can't change\n                # the page\n                num_attempts -= 1\n                if num_attempts == 0:\n                    raise ValueError(\"Could not change page.\")\n            pbar.update(len(new_homes))\n\n        # Ensure that the progress bar is at 100% at the end\n        pbar.n = pbar.total\n\n    # Filter the homes based on the monthly fee\n    homes = [\n        home\n        for home in homes\n        if home.monthly_fee is None\n        or (\n            home.monthly_fee &gt;= search_query.min_monthly_fee\n            and home.monthly_fee &lt;= search_query.max_monthly_fee\n        )\n    ]\n\n    # Filter the homes if any keyword queries were given\n    if search_query.queries:\n        homes = [\n            home\n            for home in tqdm(iterable=homes, desc=\"Filtering homes based on keywords\")\n            if home.description is not None\n            and any(\n                query.lower() in home.description.lower()\n                for query in search_query.queries\n            )\n        ]\n\n    return homes\n\n\ndef get_home_from_result(result: WebElement) -&gt; Home:docs\n    \"\"\"Get a home from a result.\n\n    Args:\n        result:\n            The result to get the home from.\n\n    Returns:\n        The home from the result.\n\n    Raises:\n        ValueError:\n            If the result could not be parsed.\n    \"\"\"\n    # Extract URL\n    candidate_urls = [\n        url.get_attribute(\"href\") or \"\"\n        for url in result.find_elements(By.XPATH, \".//a\")\n        if \"viderestilling\" in (url.get_attribute(\"href\") or \"\")\n    ]\n    if len(candidate_urls) == 0:\n        raise ValueError(\"Could not find URL in result.\")\n    url = candidate_urls[0].split(\"?\")[0]\n    if not url.startswith(\"https\"):\n        url = \"https://boligsiden.dk\" + url\n\n    # Extract address\n    try:\n        address = result.find_element(\n            By.XPATH,\n            \".//div[\"\n            \"contains(concat(' ', normalize-space(@class), ' '), ' bg-black ')\"\n            \"]//div[\"\n            \"contains(concat(' ', normalize-space(@class), ' '), ' font-black ')\"\n            \"]\",\n        ).text.replace(\"\\n\", \" \")\n    except NoSuchElementException:\n        raise ValueError(f\"Could not find address in result: {result.text}\")\n\n    # Extract span values\n    all_span_values = {span.text for span in result.find_elements(By.XPATH, \".//span\")}\n    span_regexes = dict(\n        price=r\"kr\\.$\",\n        size=r\"[0-9]+ m\u00b2\",\n        num_rooms=r\"[0-9]+ V\u00e6r\",\n        monthly_fee=r\"Ejerudg.*kr\\.?/md\",\n        year=r\"Opf\u00f8rt.*[0-9]{4}\",\n    )\n    values = dict()\n    for span_value in all_span_values:\n        for name, regex in span_regexes.items():\n            if re.search(pattern=regex, string=span_value) is not None:\n                values[name] = extract_number(span_value)\n\n    return Home(url=url, address=address, **values)\n\n\ndef extract_number(text: str) -&gt; int | None:docs\n    \"\"\"Extract the number from a string.\n\n    Args:\n        text:\n            The string containing the number.\n\n    Returns:\n        The number, or None if no number was found.\n    \"\"\"\n    match = re.search(r\"[0-9][0-9\\.]*\", text)\n    if match is None:\n        return None\n    match_str = match.group().replace(\".\", \"\")\n    if match_str == \"\":\n        return None\n    return int(match_str)\n</code></pre>"},{"location":"api/bolig_ping/webdriver/","title":"bolig_ping.webdriver","text":"bolig_ping.webdriver<p> source module bolig_ping.webdriver </p> <p>Webdriver used for scraping.</p> <p> Classes </p> <ul> <li> <p>Webdriver \u2014 A WebDriver to use for scraping.</p> </li> </ul> <p> source class Webdriver(num_attempts: int = 3, timeout: int = 10, sleep_time: int = 3, headless: bool = True, **_) </p> <p>A WebDriver to use for scraping.</p> <p>Initialise the WebDriver.</p> <p> Parameters </p> <ul> <li> <p>num_attempts :  int \u2014 The maximum number of attempts to get a page.</p> </li> <li> <p>timeout :  int \u2014 The maximum time to wait for a page to load, in seconds.</p> </li> <li> <p>sleep_time :  int \u2014 The time to sleep between attempts, in seconds.</p> </li> <li> <p>headless :  bool \u2014 Whether to run the WebDriver in headless mode.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>html :  str \u2014 Get the HTML of the current page.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>get_driver \u2014 Get the WebDriver options.</p> </li> <li> <p>load \u2014 Load the DOM of a web page.</p> </li> <li> <p>find_element \u2014 Find an element by XPath.</p> </li> <li> <p>find_elements \u2014 Find elements by XPath.</p> </li> <li> <p>click_element_or_ignore \u2014 Click an element by XPath, or ignore if not found.</p> </li> </ul> <p> source property Webdriver.html: str </p> <p>Get the HTML of the current page.</p> <p> Returns </p> <ul> <li> <p>str \u2014 The HTML of the current page.</p> </li> </ul> <p> source method Webdriver.get_driver() \u2192 webdriver.Chrome </p> <p>Get the WebDriver options.</p> <p> Returns </p> <ul> <li> <p>webdriver.Chrome \u2014 The WebDriver options.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ConnectionError</p> </li> </ul> <p> source method Webdriver.load(url: str) \u2192 Webdriver </p> <p>Load the DOM of a web page.</p> <p> Parameters </p> <ul> <li> <p>url :  str \u2014 The URL of the web page.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ConnectionError \u2014 If the page couldn't load.</p> </li> </ul> <p> source method Webdriver.find_element(xpath: str) \u2192 WebElement </p> <p>Find an element by XPath.</p> <p> Parameters </p> <ul> <li> <p>xpath :  str \u2014 The XPath of the element.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>WebElement \u2014 The element found by the XPath, or None if not found.</p> </li> </ul> <p> source method Webdriver.find_elements(xpath: str) \u2192 list[WebElement] </p> <p>Find elements by XPath.</p> <p> Parameters </p> <ul> <li> <p>xpath :  str \u2014 The XPath of the elements.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[WebElement] \u2014 The elements found by the XPath.</p> </li> </ul> <p> source method Webdriver.click_element_or_ignore(xpath: str) \u2192 None </p> <p>Click an element by XPath, or ignore if not found.</p> <p> Parameters </p> <ul> <li> <p>xpath :  str \u2014 The XPath of the element.</p> </li> </ul>"},{"location":"src/bolig_ping/webdriver/","title":"bolig_ping.webdriver","text":"bolig_ping.webdriver<p> docs module bolig_ping.webdriver </p> <pre><code>\"\"\"Webdriver used for scraping.\"\"\"\n\nimport logging\nfrom time import sleep\n\nfrom selenium import webdriver\nfrom selenium.common import WebDriverException\nfrom selenium.common.exceptions import (\n    NoSuchElementException,\n    SessionNotCreatedException,\n    TimeoutException,\n)\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.remote.webelement import WebElement\n\nlogger = logging.getLogger(__package__)\n\n\nclass Webdriver:docs\n    \"\"\"A WebDriver to use for scraping.\"\"\"\n\n    def __init__(\n        self,\n        num_attempts: int = 3,\n        timeout: int = 10,\n        sleep_time: int = 3,\n        headless: bool = True,\n        **_,\n    ) -&gt; None:\n        \"\"\"Initialise the WebDriver.\n\n        Args:\n            num_attempts:\n                The maximum number of attempts to get a page.\n            timeout:\n                The maximum time to wait for a page to load, in seconds.\n            sleep_time:\n                The time to sleep between attempts, in seconds.\n            headless:\n                Whether to run the WebDriver in headless mode.\n        \"\"\"\n        self.num_attempts = num_attempts\n        self.timeout = timeout\n        self.sleep_time = sleep_time\n        self.headless = headless\n        self.driver = self.get_driver()\n\n    @property\n    def html(self) -&gt; str:docs\n        \"\"\"Get the HTML of the current page.\n\n        Returns:\n            The HTML of the current page.\n        \"\"\"\n        return self.driver.page_source\n\n    def get_driver(self) -&gt; webdriver.Chrome:docs\n        \"\"\"Get the WebDriver options.\n\n        Returns:\n            The WebDriver options.\n        \"\"\"\n        options = webdriver.ChromeOptions()\n\n        chrome_arguments = [\n            \"--no-sandbox\",\n            \"--remote-debugging-port=9222\",\n            \"--remote-debugging-pipe\",\n            \"--autoplay-policy=no-user-gesture-required\",\n            \"--no-first-run\",\n            \"--disable-gpu\",\n            \"--use-fake-ui-for-media-stream\",\n            \"--use-fake-device-for-media-stream\",\n            \"--disable-sync\",\n            \"--disable-dev-shm-usage\",\n            \"--start-maximized\",\n        ]\n        for argument in chrome_arguments:\n            options.add_argument(argument=argument)\n\n        if self.headless:\n            options.add_argument(\"--headless=new\")\n\n        attempts = 3\n        for _ in range(attempts):\n            try:\n                driver = webdriver.Chrome(options=options)\n                break\n            except SessionNotCreatedException:\n                logger.error(\"Could not create a new session. Trying again...\")\n                sleep(3)\n        else:\n            raise ConnectionError(\"Could not create a new session.\")\n\n        driver.set_page_load_timeout(time_to_wait=self.timeout)\n        return driver\n\n    def load(self, url: str) -&gt; \"Webdriver\":docs\n        \"\"\"Load the DOM of a web page.\n\n        Args:\n            url:\n                The URL of the web page.\n\n        Raises:\n            ConnectionError:\n                If the page couldn't load.\n        \"\"\"\n        for _ in range(self.num_attempts):\n            try:\n                self.driver.get(url=url)\n                sleep(self.sleep_time)\n                return self\n            except (WebDriverException, TimeoutException) as e:\n                logger.error(\n                    f\"{type(e).__name__} occurred while fetching the web page {url!r}. \"\n                    f\"Retrying...\"\n                )\n                sleep(self.sleep_time)\n                return self\n        else:\n            raise ConnectionError(f\"Could not load website {url}.\")\n\n    def find_element(self, xpath: str) -&gt; WebElement:docs\n        \"\"\"Find an element by XPath.\n\n        Args:\n            xpath:\n                The XPath of the element.\n\n        Returns:\n            The element found by the XPath, or None if not found.\n        \"\"\"\n        return self.driver.find_element(by=By.XPATH, value=xpath)\n\n    def find_elements(self, xpath: str) -&gt; list[WebElement]:docs\n        \"\"\"Find elements by XPath.\n\n        Args:\n            xpath:\n                The XPath of the elements.\n\n        Returns:\n            The elements found by the XPath.\n        \"\"\"\n        return self.driver.find_elements(by=By.XPATH, value=xpath)\n\n    def click_element_or_ignore(self, xpath: str) -&gt; None:docs\n        \"\"\"Click an element by XPath, or ignore if not found.\n\n        Args:\n            xpath:\n                The XPath of the element.\n        \"\"\"\n        try:\n            self.find_element(xpath=xpath).click()\n            sleep(3)\n        except NoSuchElementException:\n            pass\n</code></pre>"}]}