{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bolig Ping","text":"<p>Get a ping when your dream flat in Denmark becomes available on Boligsiden.dk.</p> <p> </p> <p>Developer:</p> <ul> <li>Dan Saattrup Nielsen (saattrupdan@gmail.com)</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>The easiest way to use the package is as a uv tool. You can simply start searching for flats using the following command:</p> <pre><code>uvx bolig-ping --city k\u00f8benhavn\n</code></pre> <p>This both installs the package and runs the command. All the available options are listed below, but you can always get these by running the following command:</p> <pre><code>uvx bolig-ping --help\n</code></pre> <p>To be able to send emails, you have to create a Google app password, and store both your Gmail email address and the app password in the environment variables <code>GMAIL_EMAIL</code> and <code>GMAIL_PASSWORD</code>, respectively. You can also simply store these in a <code>.env</code> file, as follows:</p> <pre><code>GMAIL_EMAIL=&lt;your-email&gt;@gmail.com\nGMAIL_PASSWORD=&lt;your-app-password&gt;\n</code></pre> <p>With this set up, you can now use the <code>--email</code> option to receive an email with new flats that match your search criteria:</p> <pre><code>uvx bolig-ping --city k\u00f8benhavn --email &lt;your-email&gt;\n</code></pre> <p>You can also set up a recurring search if you have a server available. In this case, you can add the following line to your crontab on a server, to run the search every hour:</p> <pre><code>0 * * * * &lt;uvx-full-path&gt; bolig-ping &lt;search-arguments&gt;\n</code></pre> <p>Here <code>&lt;uvx-full-path&gt;</code> is the full path to the <code>uvx</code> command, which you can find by running <code>which uvx</code> in your terminal.</p>"},{"location":"#all-options","title":"All options","text":"<p>The following options are available:</p> <ul> <li><code>--city/-c</code> (required): The city you want to search in. This argument can be   used several times to search in multiple cities, e.g., <code>-c aarhus -c odense</code>.</li> <li><code>--min-price</code>: The minimum price of the flat, in DKK. Default is no minimum price.</li> <li><code>--max-price</code>: The maximum price of the flat, in DKK. Default is no maximum price.</li> <li><code>--min-rooms</code>: The minimum number of rooms in the flat. Default is no minimum number   of rooms.</li> <li><code>--max-rooms</code>: The maximum number of rooms in the flat. Default is no maximum number   of rooms.</li> <li><code>--min-size</code>: The minimum size of the flat, in square meters. Default is no minimum   size.</li> <li><code>--max-size</code>: The maximum size of the flat, in square meters. Default is no maximum   size.</li> <li><code>--email</code>: The email address you want to receive the ping on. Note that this needs to   have the <code>GMAIL_EMAIL</code> and <code>GMAIL_PASSWORD</code> environment variables set, as described   above. Default is to use no email address, and instead print the flats to the   console.</li> </ul>"},{"location":"api/bolig_ping/","title":"bolig_ping","text":"bolig_ping<p> source package bolig_ping </p> <p>Get a ping when your dream flat becomes available.</p> <p> Modules </p> <ul> <li> <p>bolig_ping.cache \u2014 Cache to store already sent flats.</p> </li> <li> <p>bolig_ping.cli \u2014 Command line interface for the project.</p> </li> <li> <p>bolig_ping.data_models \u2014 Data models used in the project.</p> </li> <li> <p>bolig_ping.email \u2014 Sending emails with flat listings.</p> </li> <li> <p>bolig_ping.scraper \u2014 Scraping flats available satisfying the given criteria.</p> </li> <li> <p>bolig_ping.webdriver \u2014 Webdriver used for scraping.</p> </li> </ul>"},{"location":"src/bolig_ping/","title":"bolig_ping","text":"bolig_ping<p> docs package bolig_ping </p> <pre><code>\"\"\"Get a ping when your dream flat becomes available.\"\"\"\n</code></pre>"},{"location":"api/bolig_ping/cache/","title":"bolig_ping.cache","text":"bolig_ping.cache<p> source module bolig_ping.cache </p> <p>Cache to store already sent flats.</p> <p> Functions </p> <ul> <li> <p>store_to_cache \u2014 Store the flats to the cache.</p> </li> <li> <p>remove_cached_flats \u2014 Remove the cached flats from the list of flats.</p> </li> </ul> <p> source store_to_cache(flats: list[Flat], email: str, cache_path: Path = Path('.boligping_cache')) \u2192 None </p> <p>Store the flats to the cache.</p> <p> Parameters </p> <ul> <li> <p>flats :  list[Flat] \u2014 The flats to store in the cache.</p> </li> <li> <p>email :  str \u2014 The receiver of the flats.</p> </li> <li> <p>cache_path :  optional \u2014 The path to the cache file. Defaults to \".boligping_cache\".</p> </li> </ul> <p> source remove_cached_flats(flats: list[Flat], email: str, cache_path: Path = Path('.boligping_cache')) \u2192 list[Flat] </p> <p>Remove the cached flats from the list of flats.</p> <p> Parameters </p> <ul> <li> <p>flats :  list[Flat] \u2014 The flats to remove the cached flats from.</p> </li> <li> <p>email :  str \u2014 The receiver of the flats.</p> </li> <li> <p>cache_path :  optional \u2014 The path to the cache file. Defaults to \".boligping_cache\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[Flat] \u2014 The flats without the cached flats.</p> </li> </ul>"},{"location":"src/bolig_ping/cache/","title":"bolig_ping.cache","text":"bolig_ping.cache<p> docs module bolig_ping.cache </p> <pre><code>\"\"\"Cache to store already sent flats.\"\"\"\n\nimport json\nfrom pathlib import Path\n\nfrom .data_models import Flat\n\n\ndef store_to_cache(docs\n    flats: list[Flat], email: str, cache_path: Path = Path(\".boligping_cache\")\n) -&gt; None:\n    \"\"\"Store the flats to the cache.\n\n    Args:\n        flats:\n            The flats to store in the cache.\n        email:\n            The receiver of the flats.\n        cache_path (optional):\n            The path to the cache file. Defaults to \".boligping_cache\".\n    \"\"\"\n    flats = remove_cached_flats(flats=flats, email=email, cache_path=cache_path)\n    added_flats: set[tuple[str, str]] = set()\n    with cache_path.open(\"a\") as file:\n        for flat in flats:\n            flat_id = flat.url.split(\"/\")[-1]\n            if (flat_id, email) in added_flats:\n                continue\n            flat_json = json.dumps(dict(id=flat_id, email=email))\n            file.write(f\"{flat_json}\\n\")\n            added_flats.add((flat_id, email))\n\n\ndef remove_cached_flats(docs\n    flats: list[Flat], email: str, cache_path: Path = Path(\".boligping_cache\")\n) -&gt; list[Flat]:\n    \"\"\"Remove the cached flats from the list of flats.\n\n    Args:\n        flats:\n            The flats to remove the cached flats from.\n        email:\n            The receiver of the flats.\n        cache_path (optional):\n            The path to the cache file. Defaults to \".boligping_cache\".\n\n    Returns:\n        The flats without the cached flats.\n    \"\"\"\n    cache_path.touch(exist_ok=True)\n    with cache_path.open() as file:\n        for line in file:\n            json_data = json.loads(line)\n            if json_data[\"email\"] == email:\n                flats = [\n                    flat for flat in flats if flat.url.split(\"/\")[-1] != json_data[\"id\"]\n                ]\n    return flats\n</code></pre>"},{"location":"api/bolig_ping/cli/","title":"bolig_ping.cli","text":"bolig_ping.cli<p> source module bolig_ping.cli </p> <p>Command line interface for the project.</p> <p> Functions </p> <ul> <li> <p>main \u2014 Search for flats in Denmark.</p> </li> </ul> <p> source main(city: list[str], min_price: int, max_price: int, min_rooms: int, max_rooms: int, min_size: int, max_size: int, query: list[str], email: str | None) \u2192 None </p> <p>Search for flats in Denmark.</p>"},{"location":"src/bolig_ping/cli/","title":"bolig_ping.cli","text":"bolig_ping.cli<p> docs module bolig_ping.cli </p> <pre><code>\"\"\"Command line interface for the project.\"\"\"\n\nimport logging\nimport os\n\nimport click\n\nfrom .cache import remove_cached_flats, store_to_cache\nfrom .data_models import SearchQuery\nfrom .email import compose_email, send_email\nfrom .scraper import scrape_results\n\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s \u22c5 %(message)s\", datefmt=\"%Y-%m-%d %H:%M:%S\"\n)\nlogger = logging.getLogger(__package__)\n\n\n@click.command(\"bolig_ping\")\n@click.option(\n    \"--city\",\n    \"-c\",\n    type=str,\n    multiple=True,\n    required=True,\n    help=\"The city to search for apartments in.\",\n)\n@click.option(\n    \"--min-price\",\n    type=int,\n    default=0,\n    show_default=True,\n    help=\"The minimum price of the apartment, in DKK.\",\n)\n@click.option(\n    \"--max-price\",\n    type=int,\n    default=int(1e9),\n    show_default=True,\n    help=\"The maximum price of the apartment, in DKK.\",\n)\n@click.option(\n    \"--min-rooms\",\n    type=int,\n    default=1,\n    show_default=True,\n    help=\"The minimum number of rooms in the apartment.\",\n)\n@click.option(\n    \"--max-rooms\",\n    type=int,\n    default=int(1e9),\n    show_default=True,\n    help=\"The maximum number of rooms in the apartment.\",\n)\n@click.option(\n    \"--min-size\",\n    type=int,\n    default=0,\n    show_default=True,\n    help=\"The minimum size of the apartment, in square meters.\",\n)\n@click.option(\n    \"--max-size\",\n    type=int,\n    default=int(1e9),\n    show_default=True,\n    help=\"The maximum size of the apartment, in square meters.\",\n)\n@click.option(\n    \"--email\",\n    type=str,\n    default=None,\n    show_default=True,\n    help=\"Email address to send the notification to, or None to print to stdout.\",\n)\n@click.option(\"--query\", \"-q\", multiple=True, help=\"A query to filter the results by.\")\ndef main(docs\n    city: list[str],\n    min_price: int,\n    max_price: int,\n    min_rooms: int,\n    max_rooms: int,\n    min_size: int,\n    max_size: int,\n    query: list[str],\n    email: str | None,\n) -&gt; None:\n    \"\"\"Search for flats in Denmark.\"\"\"\n    cities = [\n        c.replace(\" \", \"-\")\n        .replace(\"\u00f8\", \"oe\")\n        .replace(\"\u00e6\", \"ae\")\n        .replace(\"\u00e5\", \"aa\")\n        .lower()\n        for c in city\n    ]\n    search_query = SearchQuery(\n        cities=cities,\n        min_price=min_price,\n        max_price=max_price,\n        min_rooms=min_rooms,\n        max_rooms=max_rooms,\n        min_size=min_size,\n        max_size=max_size,\n        queries=query,\n    )\n    flats = scrape_results(search_query=search_query)\n    flats = remove_cached_flats(flats=flats, email=email or \"no-email\")\n    logger.info(f\"Found {len(flats)} new flats that satisfy the search query.\")\n    if flats:\n        if email is not None:\n            subject, contents = compose_email(flats=flats)\n            send_email(\n                from_email=os.environ[\"GMAIL_EMAIL\"],\n                password=os.environ[\"GMAIL_PASSWORD\"],\n                to_email=email,\n                subject=subject,\n                contents=contents,\n            )\n            logger.info(f\"Sent the flats to {email}.\")\n        else:\n            logger.info(\n                \"No email provided, so printing the flats here:\\n\\n\"\n                + \"\\n\\n\".join(flat.to_html() for flat in flats)\n            )\n        store_to_cache(flats=flats, email=email or \"no-email\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"api/bolig_ping/data_models/","title":"bolig_ping.data_models","text":"bolig_ping.data_models<p> source module bolig_ping.data_models </p> <p>Data models used in the project.</p> <p> Classes </p> <ul> <li> <p>SearchQuery \u2014 A flat search query.</p> </li> <li> <p>Flat \u2014 A flat listing.</p> </li> </ul> <p> source class SearchQuery() </p> <p><p>Bases : BaseModel</p></p> <p>A flat search query.</p> <p> Attributes </p> <ul> <li> <p>model_config :  ClassVar[ConfigDict] \u2014 Configuration for the model, should be a dictionary conforming to [<code>ConfigDict</code>][pydantic.config.ConfigDict].</p> </li> <li> <p>model_extra :  dict[str, Any] | None \u2014 Get extra fields set during validation.</p> </li> <li> <p>model_fields_set :  set[str] \u2014 Returns the set of fields that have been explicitly set on this model instance.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>get_url \u2014 Get the URL for the search query.</p> </li> </ul> <p> source method SearchQuery.get_url() \u2192 str </p> <p>Get the URL for the search query.</p> <p> Returns </p> <ul> <li> <p>str \u2014 The URL for the search query.</p> </li> </ul> <p> source class Flat() </p> <p><p>Bases : BaseModel</p></p> <p>A flat listing.</p> <p> Attributes </p> <ul> <li> <p>model_config :  ClassVar[ConfigDict] \u2014 Configuration for the model, should be a dictionary conforming to [<code>ConfigDict</code>][pydantic.config.ConfigDict].</p> </li> <li> <p>model_extra :  dict[str, Any] | None \u2014 Get extra fields set during validation.</p> </li> <li> <p>model_fields_set :  set[str] \u2014 Returns the set of fields that have been explicitly set on this model instance.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>to_html \u2014 Get the flat as an HTML string.</p> </li> </ul> <p> source method Flat.to_html() \u2192 str </p> <p>Get the flat as an HTML string.</p> <p> Returns </p> <ul> <li> <p>str \u2014 The flat as an HTML string.</p> </li> </ul>"},{"location":"src/bolig_ping/data_models/","title":"bolig_ping.data_models","text":"bolig_ping.data_models<p> docs module bolig_ping.data_models </p> <pre><code>\"\"\"Data models used in the project.\"\"\"\n\nfrom pydantic import BaseModel\n\n\nclass SearchQuery(BaseModel):docs\n    \"\"\"A flat search query.\"\"\"\n\n    cities: list[str]\n    min_price: int\n    max_price: int\n    min_rooms: int\n    max_rooms: int\n    min_size: int\n    max_size: int\n    queries: list[str]\n\n    def get_url(self) -&gt; str:docs\n        \"\"\"Get the URL for the search query.\n\n        Returns:\n            The URL for the search query.\n        \"\"\"\n        url = \"https://www.boligsiden.dk/by/{}/tilsalg/ejerlejlighed\".format(\n            \",\".join(self.cities)\n        )\n        arguments: dict[str, str | int] = dict(\n            priceMin=self.min_price,\n            priceMax=self.max_price,\n            numberOfRoomsMin=self.min_rooms,\n            numberOfRoomsMax=self.max_rooms,\n            areaMin=self.min_size,\n            areaMax=self.max_size,\n        )\n        if self.queries:\n            arguments[\"text\"] = \",\".join(self.queries)\n        url += \"?\" + \"&amp;\".join(f\"{key}={value}\" for key, value in arguments.items())\n        return url\n\n\nclass Flat(BaseModel):docs\n    \"\"\"A flat listing.\"\"\"\n\n    url: str\n    address: str\n    price: int | None\n    num_rooms: int | None\n    size: int | None\n    monthly_fee: int | None\n    year: int | None\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Get the hash of the flat.\n\n        Returns:\n            The hash of the flat.\n        \"\"\"\n        return hash(self.url)\n\n    def to_html(self) -&gt; str:docs\n        \"\"\"Get the flat as an HTML string.\n\n        Returns:\n            The flat as an HTML string.\n        \"\"\"\n        html = \"\\n\".join(\n            [\n                f\"&lt;a href='{self.url}'&gt;{self.address}&lt;/a&gt;\",\n                f\"Price: {self.price:,} kr.\",\n                f\"Number of rooms: {self.num_rooms}\",\n                f\"Size: {self.size} m\u00b2\",\n                f\"Monthly fee: {self.monthly_fee:,} kr./md\",\n                f\"Year built: {self.year}\",\n            ]\n        )\n        return html\n</code></pre>"},{"location":"api/bolig_ping/email/","title":"bolig_ping.email","text":"bolig_ping.email<p> source module bolig_ping.email </p> <p>Sending emails with flat listings.</p> <p> Functions </p> <ul> <li> <p>compose_email \u2014 Compose an email with the given flats.</p> </li> <li> <p>send_email \u2014 Send an email with the given contents.</p> </li> </ul> <p> source compose_email(flats: list[Flat]) \u2192 tuple[str, str] </p> <p>Compose an email with the given flats.</p> <p> Parameters </p> <ul> <li> <p>flats :  list[Flat] \u2014 The flats to compose the email with.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[str, str] \u2014 A pair (subject, contents) for the email.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source send_email(from_email: str, password: str, to_email: str, subject: str, contents: str) \u2192 None </p> <p>Send an email with the given contents.</p> <p> Parameters </p> <ul> <li> <p>from_email :  str \u2014 The email to send the email from.</p> </li> <li> <p>password :  str \u2014 The password for the from email.</p> </li> <li> <p>to_email :  str \u2014 The email to send the email to.</p> </li> <li> <p>subject :  str \u2014 The subject of the email.</p> </li> <li> <p>contents :  str \u2014 The contents of the email.</p> </li> </ul>"},{"location":"src/bolig_ping/email/","title":"bolig_ping.email","text":"bolig_ping.email<p> docs module bolig_ping.email </p> <pre><code>\"\"\"Sending emails with flat listings.\"\"\"\n\nimport yagmail\nfrom dotenv import load_dotenv\n\nfrom .data_models import Flat\n\nload_dotenv()\n\n\ndef compose_email(flats: list[Flat]) -&gt; tuple[str, str]:docs\n    \"\"\"Compose an email with the given flats.\n\n    Args:\n        flats:\n            The flats to compose the email with.\n\n    Returns:\n        A pair (subject, contents) for the email.\n    \"\"\"\n    match len(flats):\n        case 0:\n            raise ValueError(\"Cannot compose an email with no flats.\")\n        case 1:\n            subject = \"[BoligPing] Found a new flat!\"\n            contents = \"Hi,\\n\\nI found a new flat that you might be interested in:\\n\\n\"\n        case _:\n            subject = f\"[BoligPing] Found {len(flats)} new flats!\"\n            contents = (\n                \"Hi,\\n\\nI found some new flats that you might be interested in:\\n\\n\"\n            )\n    contents += \"\\n\\n\".join(flat.to_html() for flat in flats)\n    contents += \"\\n\\nHave a splendid day!\\n\\nBest regards,\\nBoligPing\"\n    return subject, contents\n\n\ndef send_email(docs\n    from_email: str, password: str, to_email: str, subject: str, contents: str\n) -&gt; None:\n    \"\"\"Send an email with the given contents.\n\n    Args:\n        from_email:\n            The email to send the email from.\n        password:\n            The password for the from email.\n        to_email:\n            The email to send the email to.\n        subject:\n            The subject of the email.\n        contents:\n            The contents of the email.\n    \"\"\"\n    yagmail.SMTP(user=from_email, password=password).send(\n        to=to_email, subject=subject, contents=contents\n    )\n</code></pre>"},{"location":"api/bolig_ping/scraper/","title":"bolig_ping.scraper","text":"bolig_ping.scraper<p> source module bolig_ping.scraper </p> <p>Scraping flats available satisfying the given criteria.</p> <p> Functions </p> <ul> <li> <p>scrape_results \u2014 Scrape the results of a flat search query.</p> </li> <li> <p>get_flat_from_result \u2014 Get a flat from a result.</p> </li> <li> <p>extract_number \u2014 Extract the number from a string.</p> </li> </ul> <p> source scrape_results(search_query: SearchQuery) \u2192 list[Flat] </p> <p>Scrape the results of a flat search query.</p> <p> Parameters </p> <ul> <li> <p>search_query :  SearchQuery \u2014 The search query to scrape results for.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[Flat] \u2014 A list of flats that satisfy the search query.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>HTTPError \u2014 If there was an error in the HTTP request.</p> </li> <li> <p>ValueError</p> </li> <li> <p>TimeoutError</p> </li> </ul> <p> source get_flat_from_result(result: WebElement) \u2192 Flat </p> <p>Get a flat from a result.</p> <p> Parameters </p> <ul> <li> <p>result :  WebElement \u2014 The result to get the flat from.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Flat \u2014 The flat from the result.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If the result could not be parsed.</p> </li> </ul> <p> source extract_number(text: str) \u2192 int | None </p> <p>Extract the number from a string.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The string containing the number.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>int | None \u2014 The number, or None if no number was found.</p> </li> </ul>"},{"location":"src/bolig_ping/scraper/","title":"bolig_ping.scraper","text":"bolig_ping.scraper<p> docs module bolig_ping.scraper </p> <pre><code>\"\"\"Scraping flats available satisfying the given criteria.\"\"\"\n\nimport logging\nimport re\n\nfrom selenium.common.exceptions import NoSuchElementException, TimeoutException\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.remote.webelement import WebElement\nfrom tqdm.auto import tqdm\n\nfrom .data_models import Flat, SearchQuery\nfrom .webdriver import Webdriver\n\nlogger = logging.getLogger(__package__)\n\n\ndef scrape_results(search_query: SearchQuery) -&gt; list[Flat]:docs\n    \"\"\"Scrape the results of a flat search query.\n\n    Args:\n        search_query:\n            The search query to scrape results for.\n\n    Returns:\n        A list of flats that satisfy the search query.\n\n    Raises:\n        HTTPError:\n            If there was an error in the HTTP request.\n    \"\"\"\n    url = search_query.get_url()\n    logger.info(f\"Fetching URL {url!r}...\")\n    webdriver = Webdriver().load(url=url)\n\n    # Close the cookie banner\n    logger.info(\"Closing cookie banner...\")\n    webdriver.click_element_or_ignore(\n        xpath=\"//button[@id='didomi-notice-disagree-button']\"\n    )\n\n    # Get the number of pages\n    logger.info(\"Getting number of results...\")\n    try:\n        num_results_elt = webdriver.find_element(\n            \"//h1[contains(concat(' ', normalize-space(@class), ' '), ' text-xl ')]\"\n        )\n    except NoSuchElementException:\n        raise ValueError(\n            f\"Could not find number of results for search query: {search_query}\"\n        )\n    except TimeoutException:\n        raise TimeoutError(\n            \"Timed out while trying to fetch number of results for search query: \"\n            f\"{search_query}.\"\n        )\n\n    num_results_match = re.search(r\"[0-9]+\", num_results_elt.text)\n    if num_results_match is None:\n        raise ValueError(\"Could not find number of results.\")\n    num_results = int(num_results_match.group())\n\n    # Extract the flats from the first page\n    logger.info(\"Scraping first page...\")\n    results = webdriver.find_elements(\n        \"//div[@data-testid='case-list-card' and \"\n        \"contains(concat(' ', normalize-space(@class), ' '), ' shadow-card ')]\"\n    )\n    flats = [get_flat_from_result(result=result) for result in results]\n\n    # Scrape the remaining pages\n    with tqdm(desc=\"Scraping pages\") as pbar:\n        # Update the progress bar\n        pbar.total = num_results\n        pbar.update(len(flats))\n\n        # Calculate the number of pages\n        num_pages = num_results // 50\n        if num_results % 50 != 0:\n            num_pages += 1\n\n        # Iterate over the remaining pages\n        for _ in range(num_pages - 1):\n            # Go to next page page\n            webdriver.click_element_or_ignore(\n                xpath=\"//ul[@role='navigation']//a[@role='button' and @rel='next']\"\n            )\n\n            # Get the results, where we keep trying in case the page hasn't changed\n            # correctly\n            num_flats = len(flats)\n            new_flats = []\n            num_attempts = 3\n            while len(flats) == num_flats:\n                # Get the results\n                results = webdriver.find_elements(\n                    \"//div[\"\n                    \"@data-testid='case-list-card' and contains(\"\n                    \"concat(' ', normalize-space(@class), ' '), ' shadow-card ')\"\n                    \"]\"\n                )\n                new_flats = [get_flat_from_result(result=result) for result in results]\n                flats.extend(new_flats)\n                flats = list(set(flats))\n\n                # Monitor the number of attempts and raise an error if we can't change\n                # the page\n                num_attempts -= 1\n                if num_attempts == 0:\n                    raise ValueError(\"Could not change page.\")\n            pbar.update(len(new_flats))\n\n        # Ensure that the progress bar is at 100% at the end\n        pbar.n = pbar.total\n\n    return flats\n\n\ndef get_flat_from_result(result: WebElement) -&gt; Flat:docs\n    \"\"\"Get a flat from a result.\n\n    Args:\n        result:\n            The result to get the flat from.\n\n    Returns:\n        The flat from the result.\n\n    Raises:\n        ValueError:\n            If the result could not be parsed.\n    \"\"\"\n    # Extract URL\n    candidate_urls = [\n        url.get_attribute(\"href\") or \"\"\n        for url in result.find_elements(By.XPATH, \".//a\")\n        if \"viderestilling\" in (url.get_attribute(\"href\") or \"\")\n    ]\n    if len(candidate_urls) == 0:\n        raise ValueError(\"Could not find URL in result.\")\n    url = candidate_urls[0].split(\"?\")[0]\n    if not url.startswith(\"https\"):\n        url = \"https://boligsiden.dk\" + url\n\n    # Extract address\n    try:\n        address = result.find_element(\n            By.XPATH,\n            \".//div[\"\n            \"contains(concat(' ', normalize-space(@class), ' '), ' bg-black ')\"\n            \"]//div[\"\n            \"contains(concat(' ', normalize-space(@class), ' '), ' font-black ')\"\n            \"]\",\n        ).text.replace(\"\\n\", \" \")\n    except NoSuchElementException:\n        raise ValueError(f\"Could not find address in result: {result.text}\")\n\n    # Extract span values\n    all_span_values = {span.text for span in result.find_elements(By.XPATH, \".//span\")}\n    span_regexes = dict(\n        price=r\"kr\\.$\",\n        size=r\"[0-9]+ m\u00b2\",\n        num_rooms=r\"[0-9]+ V\u00e6r\",\n        monthly_fee=r\"Ejerudg.*kr\\.?/md\",\n        year=r\"Opf\u00f8rt.*[0-9]{4}\",\n    )\n    values = dict()\n    for span_value in all_span_values:\n        for name, regex in span_regexes.items():\n            if re.search(pattern=regex, string=span_value) is not None:\n                values[name] = extract_number(span_value)\n\n    return Flat(url=url, address=address, **values)\n\n\ndef extract_number(text: str) -&gt; int | None:docs\n    \"\"\"Extract the number from a string.\n\n    Args:\n        text:\n            The string containing the number.\n\n    Returns:\n        The number, or None if no number was found.\n    \"\"\"\n    match = re.search(r\"[0-9][0-9\\.]*\", text)\n    if match is None:\n        return None\n    match_str = match.group().replace(\".\", \"\")\n    if match_str == \"\":\n        return None\n    return int(match_str)\n</code></pre>"},{"location":"api/bolig_ping/webdriver/","title":"bolig_ping.webdriver","text":"bolig_ping.webdriver<p> source module bolig_ping.webdriver </p> <p>Webdriver used for scraping.</p> <p> Classes </p> <ul> <li> <p>Webdriver \u2014 A WebDriver to use for scraping.</p> </li> </ul> <p> source class Webdriver(num_attempts: int = 3, timeout: int = 10, sleep_time: int = 3, headless: bool = True, **_) </p> <p>A WebDriver to use for scraping.</p> <p>Initialise the WebDriver.</p> <p> Parameters </p> <ul> <li> <p>num_attempts :  int \u2014 The maximum number of attempts to get a page.</p> </li> <li> <p>timeout :  int \u2014 The maximum time to wait for a page to load, in seconds.</p> </li> <li> <p>sleep_time :  int \u2014 The time to sleep between attempts, in seconds.</p> </li> <li> <p>headless :  bool \u2014 Whether to run the WebDriver in headless mode.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>html :  str \u2014 Get the HTML of the current page.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>get_driver \u2014 Get the WebDriver options.</p> </li> <li> <p>load \u2014 Load the DOM of a web page.</p> </li> <li> <p>find_element \u2014 Find an element by XPath.</p> </li> <li> <p>find_elements \u2014 Find elements by XPath.</p> </li> <li> <p>click_element_or_ignore \u2014 Click an element by XPath, or ignore if not found.</p> </li> </ul> <p> source property Webdriver.html: str </p> <p>Get the HTML of the current page.</p> <p> Returns </p> <ul> <li> <p>str \u2014 The HTML of the current page.</p> </li> </ul> <p> source method Webdriver.get_driver() \u2192 webdriver.Chrome </p> <p>Get the WebDriver options.</p> <p> Returns </p> <ul> <li> <p>webdriver.Chrome \u2014 The WebDriver options.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ConnectionError</p> </li> </ul> <p> source method Webdriver.load(url: str) \u2192 Webdriver </p> <p>Load the DOM of a web page.</p> <p> Parameters </p> <ul> <li> <p>url :  str \u2014 The URL of the web page.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ConnectionError \u2014 If the page couldn't load.</p> </li> </ul> <p> source method Webdriver.find_element(xpath: str) \u2192 WebElement </p> <p>Find an element by XPath.</p> <p> Parameters </p> <ul> <li> <p>xpath :  str \u2014 The XPath of the element.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>WebElement \u2014 The element found by the XPath, or None if not found.</p> </li> </ul> <p> source method Webdriver.find_elements(xpath: str) \u2192 list[WebElement] </p> <p>Find elements by XPath.</p> <p> Parameters </p> <ul> <li> <p>xpath :  str \u2014 The XPath of the elements.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[WebElement] \u2014 The elements found by the XPath.</p> </li> </ul> <p> source method Webdriver.click_element_or_ignore(xpath: str) \u2192 None </p> <p>Click an element by XPath, or ignore if not found.</p> <p> Parameters </p> <ul> <li> <p>xpath :  str \u2014 The XPath of the element.</p> </li> </ul>"},{"location":"src/bolig_ping/webdriver/","title":"bolig_ping.webdriver","text":"bolig_ping.webdriver<p> docs module bolig_ping.webdriver </p> <pre><code>\"\"\"Webdriver used for scraping.\"\"\"\n\nimport logging\nfrom time import sleep\n\nfrom selenium import webdriver\nfrom selenium.common import WebDriverException\nfrom selenium.common.exceptions import (\n    NoSuchElementException,\n    SessionNotCreatedException,\n    TimeoutException,\n)\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.remote.webelement import WebElement\n\nlogger = logging.getLogger(__package__)\n\n\nclass Webdriver:docs\n    \"\"\"A WebDriver to use for scraping.\"\"\"\n\n    def __init__(\n        self,\n        num_attempts: int = 3,\n        timeout: int = 10,\n        sleep_time: int = 3,\n        headless: bool = True,\n        **_,\n    ) -&gt; None:\n        \"\"\"Initialise the WebDriver.\n\n        Args:\n            num_attempts:\n                The maximum number of attempts to get a page.\n            timeout:\n                The maximum time to wait for a page to load, in seconds.\n            sleep_time:\n                The time to sleep between attempts, in seconds.\n            headless:\n                Whether to run the WebDriver in headless mode.\n        \"\"\"\n        self.num_attempts = num_attempts\n        self.timeout = timeout\n        self.sleep_time = sleep_time\n        self.headless = headless\n        self.driver = self.get_driver()\n\n    @property\n    def html(self) -&gt; str:docs\n        \"\"\"Get the HTML of the current page.\n\n        Returns:\n            The HTML of the current page.\n        \"\"\"\n        return self.driver.page_source\n\n    def get_driver(self) -&gt; webdriver.Chrome:docs\n        \"\"\"Get the WebDriver options.\n\n        Returns:\n            The WebDriver options.\n        \"\"\"\n        options = webdriver.ChromeOptions()\n\n        chrome_arguments = [\n            \"--no-sandbox\",\n            \"--remote-debugging-port=9222\",\n            \"--remote-debugging-pipe\",\n            \"--autoplay-policy=no-user-gesture-required\",\n            \"--no-first-run\",\n            \"--disable-gpu\",\n            \"--use-fake-ui-for-media-stream\",\n            \"--use-fake-device-for-media-stream\",\n            \"--disable-sync\",\n            \"--disable-dev-shm-usage\",\n            \"--start-maximized\",\n        ]\n        for argument in chrome_arguments:\n            options.add_argument(argument=argument)\n\n        if self.headless:\n            options.add_argument(\"--headless=new\")\n\n        attempts = 3\n        for _ in range(attempts):\n            try:\n                driver = webdriver.Chrome(options=options)\n                break\n            except SessionNotCreatedException:\n                logger.error(\"Could not create a new session. Trying again...\")\n                sleep(3)\n        else:\n            raise ConnectionError(\"Could not create a new session.\")\n\n        driver.set_page_load_timeout(time_to_wait=self.timeout)\n        return driver\n\n    def load(self, url: str) -&gt; \"Webdriver\":docs\n        \"\"\"Load the DOM of a web page.\n\n        Args:\n            url:\n                The URL of the web page.\n\n        Raises:\n            ConnectionError:\n                If the page couldn't load.\n        \"\"\"\n        for _ in range(self.num_attempts):\n            try:\n                self.driver.get(url=url)\n                sleep(self.sleep_time)\n                return self\n            except (WebDriverException, TimeoutException) as e:\n                logger.error(\n                    f\"{type(e).__name__} occurred while fetching the web page {url!r}. \"\n                    f\"Retrying...\"\n                )\n                sleep(self.sleep_time)\n                return self\n        else:\n            raise ConnectionError(f\"Could not load website {url}.\")\n\n    def find_element(self, xpath: str) -&gt; WebElement:docs\n        \"\"\"Find an element by XPath.\n\n        Args:\n            xpath:\n                The XPath of the element.\n\n        Returns:\n            The element found by the XPath, or None if not found.\n        \"\"\"\n        return self.driver.find_element(by=By.XPATH, value=xpath)\n\n    def find_elements(self, xpath: str) -&gt; list[WebElement]:docs\n        \"\"\"Find elements by XPath.\n\n        Args:\n            xpath:\n                The XPath of the elements.\n\n        Returns:\n            The elements found by the XPath.\n        \"\"\"\n        return self.driver.find_elements(by=By.XPATH, value=xpath)\n\n    def click_element_or_ignore(self, xpath: str) -&gt; None:docs\n        \"\"\"Click an element by XPath, or ignore if not found.\n\n        Args:\n            xpath:\n                The XPath of the element.\n        \"\"\"\n        try:\n            self.find_element(xpath=xpath).click()\n            sleep(3)\n        except NoSuchElementException:\n            pass\n</code></pre>"}]}